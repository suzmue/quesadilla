
#include <iostream>
#include "taco.h"
#include "taco/util/timers.h"
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <cmath>
#include <climits>

#include "taco/tensor.h"
#include "taco/format.h"
#include "taco/error.h"
#include "taco/util/strings.h"
#include "taco/util/files.h"
#include <cstdio>
#include <cstdlib>
#include <vector>


struct coo_t
{
	int32_t	idx0;
	int32_t	idx1;
	int32_t	idx2;
	int32_t	idx3;
	int32_t	idx4;
	double	val;
};


using namespace taco;
int cmp_01234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_34(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_4(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_01243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_43(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_3(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_01324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_24(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_01342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_42(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_2(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_01423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_23(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_01432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_32(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_02134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_02143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_02314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_14(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_02341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_41(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_1(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_02413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_13(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_02431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_31(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_03124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_03142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_03214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_03241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_03412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_12(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_03421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_21(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_04123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_04132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_04213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_04231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_04312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_04321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_10234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_10243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_10324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_10342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_10423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_10432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_12034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_12043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_12304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_04(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_12340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_40(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_0(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_12403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_03(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_12430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_30(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_13024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_13042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_13204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_13240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_13402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_02(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_13420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_20(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_14023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_14032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_14203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_14230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_14302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_14320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_20134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_20143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_20314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_20341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_20413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_20431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_21034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_21043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_21304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_21340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_21403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_21430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_23014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_23041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_23104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_23140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_23401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_01(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_23410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_10(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_24013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_24031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_24103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_24130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_24301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_24310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_30124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_30142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_30214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_30241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_30412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_30421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_31024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_31042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_31204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_31240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_31402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_31420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_32014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_32041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_32104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_32140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_32401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_32410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_34012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_34021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_34102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_34120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_34201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_34210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_40123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_40132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_40213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_40231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_40312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_40321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_41023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_41032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_41203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_41230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_41302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_41320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_42013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_42031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_42103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_42130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_42301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_42310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_43012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_43021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_43102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_43120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_43201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_43210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01234);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1234);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_234);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01243);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1243);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_243);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Fix and sort on [0, 1, 2]
	// Create buckets and quotient
	int *bucket_4012 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4012 = (int *)malloc(c_size*sizeof(int));
	int current_4012 = 0;
	bucket_4012[0] = 0;
	quotient_4012[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		bucket_4012[i] = current_4012;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4012[i];
		B4_count[idx4]--;
	}
	free(bucket_4012);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4012[perm[i]]] = C_coords_scratch[i];
		quotient_4012[perm[i]] ++;
	}
	free(quotient_4012);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1, 2])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Fix and sort on [0, 1, 2]
	// Create buckets and quotient
	int *bucket_4012 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4012 = (int *)malloc(c_size*sizeof(int));
	int current_4012 = 0;
	bucket_4012[0] = 0;
	quotient_4012[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		bucket_4012[i] = current_4012;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4012[i];
		B4_count[idx4]--;
	}
	free(bucket_4012);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4012[perm[i]]] = C_coords_scratch[i];
		quotient_4012[perm[i]] ++;
	}
	free(quotient_4012);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1, 2])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01324);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1324);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_324);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01342);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1342);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_342);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1]), (3, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1]), (3, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01423);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1423);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_423);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01432);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1432);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_432);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0, 1]), (4, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	// Fix and sort on [0, 1]
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0, 1]), (4, [0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02134);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2134);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_134);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02143);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2143);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_143);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0, 2, 1]
	// Create buckets and quotient
	int *bucket_4021 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4021 = (int *)malloc(c_size*sizeof(int));
	int current_4021 = 0;
	bucket_4021[0] = 0;
	quotient_4021[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		bucket_4021[i] = current_4021;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4021[i];
		B4_count[idx4]--;
	}
	free(bucket_4021);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4021[perm[i]]] = C_coords_scratch[i];
		quotient_4021[perm[i]] ++;
	}
	free(quotient_4021);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0, 2, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0, 2, 1]
	// Create buckets and quotient
	int *bucket_4021 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4021 = (int *)malloc(c_size*sizeof(int));
	int current_4021 = 0;
	bucket_4021[0] = 0;
	quotient_4021[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		bucket_4021[i] = current_4021;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4021[i];
		B4_count[idx4]--;
	}
	free(bucket_4021);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4021[perm[i]]] = C_coords_scratch[i];
		quotient_4021[perm[i]] ++;
	}
	free(quotient_4021);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0, 2, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02314);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2314);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_314);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02341);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2341);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_341);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02413);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2413);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_413);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02431);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2431);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_431);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0]), (2, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03124);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3124);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_124);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03142);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3142);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_142);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0, 3, 1]
	// Create buckets and quotient
	int *bucket_4031 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4031 = (int *)malloc(c_size*sizeof(int));
	int current_4031 = 0;
	bucket_4031[0] = 0;
	quotient_4031[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		bucket_4031[i] = current_4031;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4031[i];
		B4_count[idx4]--;
	}
	free(bucket_4031);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4031[perm[i]]] = C_coords_scratch[i];
		quotient_4031[perm[i]] ++;
	}
	free(quotient_4031);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0, 3, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0, 3, 1]
	// Create buckets and quotient
	int *bucket_4031 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4031 = (int *)malloc(c_size*sizeof(int));
	int current_4031 = 0;
	bucket_4031[0] = 0;
	quotient_4031[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		bucket_4031[i] = current_4031;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4031[i];
		B4_count[idx4]--;
	}
	free(bucket_4031);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4031[perm[i]]] = C_coords_scratch[i];
		quotient_4031[perm[i]] ++;
	}
	free(quotient_4031);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0, 3, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03214);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3214);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_214);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03241);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3241);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_241);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (2, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (2, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03412);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3412);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_412);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03421);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3421);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_421);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0]), (3, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04123);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4123);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_123);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04132);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4132);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_132);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0, 4, 1]
	// Create buckets and quotient
	int *bucket_3041 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3041 = (int *)malloc(c_size*sizeof(int));
	int current_3041 = 0;
	bucket_3041[0] = 0;
	quotient_3041[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		bucket_3041[i] = current_3041;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3041[i];
		B3_count[idx3]--;
	}
	free(bucket_3041);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3041[perm[i]]] = C_coords_scratch[i];
		quotient_3041[perm[i]] ++;
	}
	free(quotient_3041);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0, 4, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Fix and sort on [0, 4, 1]
	// Create buckets and quotient
	int *bucket_3041 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3041 = (int *)malloc(c_size*sizeof(int));
	int current_3041 = 0;
	bucket_3041[0] = 0;
	quotient_3041[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		bucket_3041[i] = current_3041;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3041[i];
		B3_count[idx3]--;
	}
	free(bucket_3041);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3041[perm[i]]] = C_coords_scratch[i];
		quotient_3041[perm[i]] ++;
	}
	free(quotient_3041);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0]), (3, [0, 4, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04213);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4213);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_213);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04231);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4231);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_231);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (2, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (2, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04312);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4312);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_312);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04321);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4321);
			qsort_start = i;
		}
	}
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_321);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (3, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	// Fix and sort on [0]
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [0]), (3, [0]), (4, [0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 0, 2, 3, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10234);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0234);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_234);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 0, 2, 4, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10243);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0243);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_243);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0, 2]
	// Create buckets and quotient
	int *bucket_4102 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4102 = (int *)malloc(c_size*sizeof(int));
	int current_4102 = 0;
	bucket_4102[0] = 0;
	quotient_4102[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		bucket_4102[i] = current_4102;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4102[i];
		B4_count[idx4]--;
	}
	free(bucket_4102);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4102[perm[i]]] = C_coords_scratch[i];
		quotient_4102[perm[i]] ++;
	}
	free(quotient_4102);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0, 2])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0, 2]
	// Create buckets and quotient
	int *bucket_4102 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4102 = (int *)malloc(c_size*sizeof(int));
	int current_4102 = 0;
	bucket_4102[0] = 0;
	quotient_4102[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		bucket_4102[i] = current_4102;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4102[i];
		B4_count[idx4]--;
	}
	free(bucket_4102);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4102[perm[i]]] = C_coords_scratch[i];
		quotient_4102[perm[i]] ++;
	}
	free(quotient_4102);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0, 2])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 0, 3, 2, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10324);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0324);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_324);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 0, 3, 4, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10342);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0342);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_342);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0]), (3, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0]), (3, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 0, 4, 2, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10423);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0423);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_423);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 0, 4, 3, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10432);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0432);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_432);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [1, 0]), (4, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	// Fix and sort on [1, 0]
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [1, 0]), (4, [1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 2, 0, 3, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12034);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2034);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_034);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 2, 0, 4, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12043);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2043);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_043);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 2, 0]
	// Create buckets and quotient
	int *bucket_4120 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4120 = (int *)malloc(c_size*sizeof(int));
	int current_4120 = 0;
	bucket_4120[0] = 0;
	quotient_4120[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		bucket_4120[i] = current_4120;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4120[i];
		B4_count[idx4]--;
	}
	free(bucket_4120);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4120[perm[i]]] = C_coords_scratch[i];
		quotient_4120[perm[i]] ++;
	}
	free(quotient_4120);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, [1, 2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 2, 0]
	// Create buckets and quotient
	int *bucket_4120 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4120 = (int *)malloc(c_size*sizeof(int));
	int current_4120 = 0;
	bucket_4120[0] = 0;
	quotient_4120[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		bucket_4120[i] = current_4120;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4120[i];
		B4_count[idx4]--;
	}
	free(bucket_4120);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4120[perm[i]]] = C_coords_scratch[i];
		quotient_4120[perm[i]] ++;
	}
	free(quotient_4120);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, [1, 2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 2, 3, 0, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12304);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2304);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_304);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 2, 3, 4, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12340);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2340);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_340);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 2, 4, 0, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12403);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2403);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_403);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 2, 4, 3, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12430);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2430);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_430);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 3, 0, 2, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13024);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3024);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_024);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 3, 0, 4, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13042);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3042);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_042);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 3, 0]
	// Create buckets and quotient
	int *bucket_4130 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4130 = (int *)malloc(c_size*sizeof(int));
	int current_4130 = 0;
	bucket_4130[0] = 0;
	quotient_4130[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		bucket_4130[i] = current_4130;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4130[i];
		B4_count[idx4]--;
	}
	free(bucket_4130);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4130[perm[i]]] = C_coords_scratch[i];
		quotient_4130[perm[i]] ++;
	}
	free(quotient_4130);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, [1, 3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 3, 0]
	// Create buckets and quotient
	int *bucket_4130 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4130 = (int *)malloc(c_size*sizeof(int));
	int current_4130 = 0;
	bucket_4130[0] = 0;
	quotient_4130[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		bucket_4130[i] = current_4130;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4130[i];
		B4_count[idx4]--;
	}
	free(bucket_4130);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4130[perm[i]]] = C_coords_scratch[i];
		quotient_4130[perm[i]] ++;
	}
	free(quotient_4130);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, [1, 3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 3, 2, 0, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13204);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3204);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_204);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 3, 2, 4, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13240);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3240);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_240);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 3, 4, 0, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13402);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3402);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_402);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 3, 4, 2, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13420);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3420);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_420);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 4, 0, 2, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14023);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4023);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_023);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 4, 0, 3, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14032);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4032);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_032);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 4, 0]
	// Create buckets and quotient
	int *bucket_3140 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3140 = (int *)malloc(c_size*sizeof(int));
	int current_3140 = 0;
	bucket_3140[0] = 0;
	quotient_3140[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		bucket_3140[i] = current_3140;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3140[i];
		B3_count[idx3]--;
	}
	free(bucket_3140);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3140[perm[i]]] = C_coords_scratch[i];
		quotient_3140[perm[i]] ++;
	}
	free(quotient_3140);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, [1, 4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Fix and sort on [1, 4, 0]
	// Create buckets and quotient
	int *bucket_3140 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3140 = (int *)malloc(c_size*sizeof(int));
	int current_3140 = 0;
	bucket_3140[0] = 0;
	quotient_3140[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		bucket_3140[i] = current_3140;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3140[i];
		B3_count[idx3]--;
	}
	free(bucket_3140);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3140[perm[i]]] = C_coords_scratch[i];
		quotient_3140[perm[i]] ++;
	}
	free(quotient_3140);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, [1, 4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 4, 2, 0, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14203);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4203);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_203);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 4, 2, 3, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14230);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4230);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_230);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 4, 3, 0, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14302);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4302);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_302);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (1, 4, 3, 2, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14320);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4320);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_320);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, []), (1, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 0, 1, 3, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20134);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0134);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_134);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 0, 1, 4, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20143);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0143);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_143);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0, 1]
	// Create buckets and quotient
	int *bucket_4201 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4201 = (int *)malloc(c_size*sizeof(int));
	int current_4201 = 0;
	bucket_4201[0] = 0;
	quotient_4201[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		bucket_4201[i] = current_4201;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4201[i];
		B4_count[idx4]--;
	}
	free(bucket_4201);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4201[perm[i]]] = C_coords_scratch[i];
		quotient_4201[perm[i]] ++;
	}
	free(quotient_4201);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0, 1]
	// Create buckets and quotient
	int *bucket_4201 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4201 = (int *)malloc(c_size*sizeof(int));
	int current_4201 = 0;
	bucket_4201[0] = 0;
	quotient_4201[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		bucket_4201[i] = current_4201;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4201[i];
		B4_count[idx4]--;
	}
	free(bucket_4201);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4201[perm[i]]] = C_coords_scratch[i];
		quotient_4201[perm[i]] ++;
	}
	free(quotient_4201);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 0, 3, 1, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20314);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0314);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_314);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 0, 3, 4, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20341);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0341);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_341);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0]), (3, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0]), (3, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 0, 4, 1, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20413);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0413);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_413);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 0, 4, 3, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20431);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0431);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_431);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [2, 0]), (4, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	// Fix and sort on [2, 0]
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [2, 0]), (4, [2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 1, 0, 3, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21034);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1034);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_034);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 1, 0, 4, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21043);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1043);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_043);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 1, 0]
	// Create buckets and quotient
	int *bucket_4210 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4210 = (int *)malloc(c_size*sizeof(int));
	int current_4210 = 0;
	bucket_4210[0] = 0;
	quotient_4210[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		bucket_4210[i] = current_4210;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4210[i];
		B4_count[idx4]--;
	}
	free(bucket_4210);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4210[perm[i]]] = C_coords_scratch[i];
		quotient_4210[perm[i]] ++;
	}
	free(quotient_4210);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, [2, 1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 1, 0]
	// Create buckets and quotient
	int *bucket_4210 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4210 = (int *)malloc(c_size*sizeof(int));
	int current_4210 = 0;
	bucket_4210[0] = 0;
	quotient_4210[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		bucket_4210[i] = current_4210;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4210[i];
		B4_count[idx4]--;
	}
	free(bucket_4210);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4210[perm[i]]] = C_coords_scratch[i];
		quotient_4210[perm[i]] ++;
	}
	free(quotient_4210);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, [2, 1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 1, 3, 0, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21304);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1304);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_304);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 1, 3, 4, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21340);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1340);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_340);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 1, 4, 0, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21403);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1403);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_403);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 1, 4, 3, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21430);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1430);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_430);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (1, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 3, 0, 1, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23014);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3014);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_014);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 3, 0, 4, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23041);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3041);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_041);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 3, 0]
	// Create buckets and quotient
	int *bucket_4230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4230 = (int *)malloc(c_size*sizeof(int));
	int current_4230 = 0;
	bucket_4230[0] = 0;
	quotient_4230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		bucket_4230[i] = current_4230;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4230[i];
		B4_count[idx4]--;
	}
	free(bucket_4230);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4230[perm[i]]] = C_coords_scratch[i];
		quotient_4230[perm[i]] ++;
	}
	free(quotient_4230);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, [2, 3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 3, 0]
	// Create buckets and quotient
	int *bucket_4230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4230 = (int *)malloc(c_size*sizeof(int));
	int current_4230 = 0;
	bucket_4230[0] = 0;
	quotient_4230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		bucket_4230[i] = current_4230;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4230[i];
		B4_count[idx4]--;
	}
	free(bucket_4230);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4230[perm[i]]] = C_coords_scratch[i];
		quotient_4230[perm[i]] ++;
	}
	free(quotient_4230);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, [2, 3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 3, 1, 0, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23104);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3104);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_104);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 3, 1, 4, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23140);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3140);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_140);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 3, 4, 0, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23401);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3401);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_401);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 3, 4, 1, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23410);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3410);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_410);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 4, 0, 1, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24013);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4013);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_013);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 4, 0, 3, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24031);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4031);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_031);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 4, 0]
	// Create buckets and quotient
	int *bucket_3240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3240 = (int *)malloc(c_size*sizeof(int));
	int current_3240 = 0;
	bucket_3240[0] = 0;
	quotient_3240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		bucket_3240[i] = current_3240;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3240[i];
		B3_count[idx3]--;
	}
	free(bucket_3240);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3240[perm[i]]] = C_coords_scratch[i];
		quotient_3240[perm[i]] ++;
	}
	free(quotient_3240);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, [2, 4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Fix and sort on [2, 4, 0]
	// Create buckets and quotient
	int *bucket_3240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3240 = (int *)malloc(c_size*sizeof(int));
	int current_3240 = 0;
	bucket_3240[0] = 0;
	quotient_3240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		bucket_3240[i] = current_3240;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3240[i];
		B3_count[idx3]--;
	}
	free(bucket_3240);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3240[perm[i]]] = C_coords_scratch[i];
		quotient_3240[perm[i]] ++;
	}
	free(quotient_3240);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, [2, 4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 4, 1, 0, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24103);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4103);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_103);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 4, 1, 3, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24130);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4130);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_130);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 4, 3, 0, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24301);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4301);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_301);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (2, 4, 3, 1, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24310);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4310);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_310);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, []), (2, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 0, 1, 2, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30124);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0124);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_124);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 0, 1, 4, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30142);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0142);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_142);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0, 1]
	// Create buckets and quotient
	int *bucket_4301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4301 = (int *)malloc(c_size*sizeof(int));
	int current_4301 = 0;
	bucket_4301[0] = 0;
	quotient_4301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		bucket_4301[i] = current_4301;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4301[i];
		B4_count[idx4]--;
	}
	free(bucket_4301);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4301[perm[i]]] = C_coords_scratch[i];
		quotient_4301[perm[i]] ++;
	}
	free(quotient_4301);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0, 1]
	// Create buckets and quotient
	int *bucket_4301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4301 = (int *)malloc(c_size*sizeof(int));
	int current_4301 = 0;
	bucket_4301[0] = 0;
	quotient_4301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		bucket_4301[i] = current_4301;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4301[i];
		B4_count[idx4]--;
	}
	free(bucket_4301);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4301[perm[i]]] = C_coords_scratch[i];
		quotient_4301[perm[i]] ++;
	}
	free(quotient_4301);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 0, 2, 1, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30214);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0214);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_214);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 0, 2, 4, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30241);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0241);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_241);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0]), (2, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0]), (2, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 0, 4, 1, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30412);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0412);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_412);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 0, 4, 2, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30421);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0421);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_421);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [3, 0]), (4, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	// Fix and sort on [3, 0]
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, [3, 0]), (4, [3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 1, 0, 2, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31024);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1024);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_024);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 1, 0, 4, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31042);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1042);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_042);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 1, 0]
	// Create buckets and quotient
	int *bucket_4310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4310 = (int *)malloc(c_size*sizeof(int));
	int current_4310 = 0;
	bucket_4310[0] = 0;
	quotient_4310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		bucket_4310[i] = current_4310;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4310[i];
		B4_count[idx4]--;
	}
	free(bucket_4310);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4310[perm[i]]] = C_coords_scratch[i];
		quotient_4310[perm[i]] ++;
	}
	free(quotient_4310);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, [3, 1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 1, 0]
	// Create buckets and quotient
	int *bucket_4310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4310 = (int *)malloc(c_size*sizeof(int));
	int current_4310 = 0;
	bucket_4310[0] = 0;
	quotient_4310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		bucket_4310[i] = current_4310;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4310[i];
		B4_count[idx4]--;
	}
	free(bucket_4310);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4310[perm[i]]] = C_coords_scratch[i];
		quotient_4310[perm[i]] ++;
	}
	free(quotient_4310);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, [3, 1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 1, 2, 0, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31204);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1204);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_204);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 1, 2, 4, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31240);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1240);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_240);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 1, 4, 0, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31402);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1402);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_402);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 1, 4, 2, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31420);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1420);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_420);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (1, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 2, 0, 1, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32014);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2014);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_014);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 2, 0, 4, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32041);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2041);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_041);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 2, 0]
	// Create buckets and quotient
	int *bucket_4320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4320 = (int *)malloc(c_size*sizeof(int));
	int current_4320 = 0;
	bucket_4320[0] = 0;
	quotient_4320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		bucket_4320[i] = current_4320;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4320[i];
		B4_count[idx4]--;
	}
	free(bucket_4320);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4320[perm[i]]] = C_coords_scratch[i];
		quotient_4320[perm[i]] ++;
	}
	free(quotient_4320);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, [3, 2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 2, 0]
	// Create buckets and quotient
	int *bucket_4320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4320 = (int *)malloc(c_size*sizeof(int));
	int current_4320 = 0;
	bucket_4320[0] = 0;
	quotient_4320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		bucket_4320[i] = current_4320;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4320[i];
		B4_count[idx4]--;
	}
	free(bucket_4320);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4320[perm[i]]] = C_coords_scratch[i];
		quotient_4320[perm[i]] ++;
	}
	free(quotient_4320);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, [3, 2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 2, 1, 0, 4)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32104);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2104);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_104);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 2, 1, 4, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32140);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2140);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_140);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (1, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 2, 4, 0, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32401);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2401);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_401);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 2, 4, 1, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32410);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2410);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_410);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (2, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 4, 0, 1, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34012);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4012);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_012);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 4, 0, 2, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34021);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4021);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_021);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 4, 0]
	// Create buckets and quotient
	int *bucket_2340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2340 = (int *)malloc(c_size*sizeof(int));
	int current_2340 = 0;
	bucket_2340[0] = 0;
	quotient_2340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		bucket_2340[i] = current_2340;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2340[i];
		B2_count[idx2]--;
	}
	free(bucket_2340);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2340[perm[i]]] = C_coords_scratch[i];
		quotient_2340[perm[i]] ++;
	}
	free(quotient_2340);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, [3, 4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Fix and sort on [3, 4, 0]
	// Create buckets and quotient
	int *bucket_2340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2340 = (int *)malloc(c_size*sizeof(int));
	int current_2340 = 0;
	bucket_2340[0] = 0;
	quotient_2340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		bucket_2340[i] = current_2340;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2340[i];
		B2_count[idx2]--;
	}
	free(bucket_2340);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2340[perm[i]]] = C_coords_scratch[i];
		quotient_2340[perm[i]] ++;
	}
	free(quotient_2340);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, []), (2, [3, 4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 4, 1, 0, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34102);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4102);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_102);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 4, 1, 2, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34120);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4120);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_120);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 4, 2, 0, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34201);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4201);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_201);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (3, 4, 2, 1, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34210);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4210);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_210);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, []), (3, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 0, 1, 2, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40123);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0123);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_123);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 0, 1, 3, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40132);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0132);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_132);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0, 1]
	// Create buckets and quotient
	int *bucket_3401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3401 = (int *)malloc(c_size*sizeof(int));
	int current_3401 = 0;
	bucket_3401[0] = 0;
	quotient_3401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		bucket_3401[i] = current_3401;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3401[i];
		B3_count[idx3]--;
	}
	free(bucket_3401);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3401[perm[i]]] = C_coords_scratch[i];
		quotient_3401[perm[i]] ++;
	}
	free(quotient_3401);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0, 1]
	// Create buckets and quotient
	int *bucket_3401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3401 = (int *)malloc(c_size*sizeof(int));
	int current_3401 = 0;
	bucket_3401[0] = 0;
	quotient_3401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		bucket_3401[i] = current_3401;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3401[i];
		B3_count[idx3]--;
	}
	free(bucket_3401);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3401[perm[i]]] = C_coords_scratch[i];
		quotient_3401[perm[i]] ++;
	}
	free(quotient_3401);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0, 1])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 0, 2, 1, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40213);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0213);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_213);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 0, 2, 3, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40231);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0231);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_231);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0]), (2, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0]), (2, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 0, 3, 1, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40312);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0312);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_312);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 0, 3, 2, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40321);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0321);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_321);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (3, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [4, 0]), (3, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	// Fix and sort on [4, 0]
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, []), (2, [4, 0]), (3, [4, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 1, 0, 2, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41023);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1023);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_023);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 1, 0, 3, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41032);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1032);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_032);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 1, 0]
	// Create buckets and quotient
	int *bucket_3410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3410 = (int *)malloc(c_size*sizeof(int));
	int current_3410 = 0;
	bucket_3410[0] = 0;
	quotient_3410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		bucket_3410[i] = current_3410;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3410[i];
		B3_count[idx3]--;
	}
	free(bucket_3410);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3410[perm[i]]] = C_coords_scratch[i];
		quotient_3410[perm[i]] ++;
	}
	free(quotient_3410);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, [4, 1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 1, 0]
	// Create buckets and quotient
	int *bucket_3410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3410 = (int *)malloc(c_size*sizeof(int));
	int current_3410 = 0;
	bucket_3410[0] = 0;
	quotient_3410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		bucket_3410[i] = current_3410;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3410[i];
		B3_count[idx3]--;
	}
	free(bucket_3410);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3410[perm[i]]] = C_coords_scratch[i];
		quotient_3410[perm[i]] ++;
	}
	free(quotient_3410);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, []), (3, [4, 1, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 1, 2, 0, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41203);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1203);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_203);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 1, 2, 3, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41230);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1230);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_230);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 1, 3, 0, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41302);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1302);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_302);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 1, 3, 2, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41320);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1320);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_320);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (1, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 2, 0, 1, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42013);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2013);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_013);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 2, 0, 3, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42031);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2031);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_031);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 2, 0]
	// Create buckets and quotient
	int *bucket_3420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3420 = (int *)malloc(c_size*sizeof(int));
	int current_3420 = 0;
	bucket_3420[0] = 0;
	quotient_3420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		bucket_3420[i] = current_3420;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3420[i];
		B3_count[idx3]--;
	}
	free(bucket_3420);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3420[perm[i]]] = C_coords_scratch[i];
		quotient_3420[perm[i]] ++;
	}
	free(quotient_3420);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, [4, 2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 2, 0]
	// Create buckets and quotient
	int *bucket_3420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3420 = (int *)malloc(c_size*sizeof(int));
	int current_3420 = 0;
	bucket_3420[0] = 0;
	quotient_3420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		bucket_3420[i] = current_3420;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3420[i];
		B3_count[idx3]--;
	}
	free(bucket_3420);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3420[perm[i]]] = C_coords_scratch[i];
		quotient_3420[perm[i]] ++;
	}
	free(quotient_3420);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, []), (3, [4, 2, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 2, 1, 0, 3)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42103);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2103);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_103);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 2, 1, 3, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42130);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2130);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_130);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (1, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 2, 3, 0, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42301);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2301);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_301);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 2, 3, 1, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42310);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2310);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_310);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (2, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 3, 0, 1, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43012);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3012);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_012);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 3, 0, 2, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43021);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3021);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_021);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 3, 0]
	// Create buckets and quotient
	int *bucket_2430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2430 = (int *)malloc(c_size*sizeof(int));
	int current_2430 = 0;
	bucket_2430[0] = 0;
	quotient_2430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		bucket_2430[i] = current_2430;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2430[i];
		B2_count[idx2]--;
	}
	free(bucket_2430);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2430[perm[i]]] = C_coords_scratch[i];
		quotient_2430[perm[i]] ++;
	}
	free(quotient_2430);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, [4, 3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Fix and sort on [4, 3, 0]
	// Create buckets and quotient
	int *bucket_2430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2430 = (int *)malloc(c_size*sizeof(int));
	int current_2430 = 0;
	bucket_2430[0] = 0;
	quotient_2430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		bucket_2430[i] = current_2430;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2430[i];
		B2_count[idx2]--;
	}
	free(bucket_2430);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2430[perm[i]]] = C_coords_scratch[i];
		quotient_2430[perm[i]] ++;
	}
	free(quotient_2430);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, []), (2, [4, 3, 0])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 3, 1, 0, 2)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43102);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3102);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_102);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 3, 1, 2, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43120);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3120);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_120);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (1, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 3, 2, 0, 1)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43201);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3201);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_201);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();

	// Sort the coordinates to be in (4, 3, 2, 1, 0)
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43210);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3210);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_210);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(2, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same || i == c_size - 1) { // Sort if at the end of a segment
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	taco::util::Timer timer;
	timer.start();
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	timer.stop();
	taco::util::TimeResults res = timer.getResult();
	cout << " |  [(1, []), (2, []), (3, []), (4, [])] ";
	cout << " | "<< res ;
	return 0;
}

int main(int argc, char* argv[]) {
  char *p;
  int SPLIT;
   std::string filename = argv[1];

  long conv = strtol(argv[2], &p, 10);
  SPLIT = conv;

  // Read tensor data  
  int order = 5;
  int * dimensions = (int*)malloc(sizeof(int)*order);
  memset(dimensions, 0, sizeof(int)*order);
  
  int32_t init_alloc_size = 1048576;
  int32_t A_capacity = init_alloc_size;
  struct coo_t *A = (struct coo_t *)malloc(sizeof(struct coo_t)* A_capacity);

  std::fstream stream;
  util::openStream(stream, filename, fstream::in);

  std::string line;
  if (!std::getline(stream, line)) {
    return -1;
  }


  int size = 0;

  do {
      if(size >= A_capacity){
          int32_t A_capacity_new = 2 * (A_capacity);
          A = (struct coo_t*)realloc(A, sizeof(struct coo_t) * A_capacity_new);
          A_capacity = A_capacity_new;
        }

    char* linePtr = (char*)line.data();

    // Generated by coo/gen_taco_to_list.py

	long idx0 = strtol(linePtr, &linePtr, 10);
	A[size].idx0 = (int32_t)idx0 - 1;
	dimensions[0] = std::max(dimensions[0], (int)idx0 - 1);
	long idx1 = strtol(linePtr, &linePtr, 10);
	A[size].idx1 = (int32_t)idx1 - 1;
	dimensions[1] = std::max(dimensions[1], (int)idx1 - 1);
	long idx2 = strtol(linePtr, &linePtr, 10);
	A[size].idx2 = (int32_t)idx2 - 1;
	dimensions[2] = std::max(dimensions[2], (int)idx2 - 1);
	long idx3 = strtol(linePtr, &linePtr, 10);
	A[size].idx3 = (int32_t)idx3 - 1;
	dimensions[3] = std::max(dimensions[3], (int)idx3 - 1);
	long idx4 = strtol(linePtr, &linePtr, 10);
	A[size].idx4 = (int32_t)idx4 - 1;
	dimensions[4] = std::max(dimensions[4], (int)idx4 - 1);

    double val = strtod(linePtr, &linePtr);
    A[size].val = val;
    size ++;

  } while (std::getline(stream, line));

  stream.close();

		if(0 == SPLIT){
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(1 == SPLIT){
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(2 == SPLIT){
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(3 == SPLIT){
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 3 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(4 == SPLIT){
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 4 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(5 == SPLIT){
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 5 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(6 == SPLIT){
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(7 == SPLIT){
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(8 == SPLIT){
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(9 == SPLIT){
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 3 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(10 == SPLIT){
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(11 == SPLIT){
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(12 == SPLIT){
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(13 == SPLIT){
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(14 == SPLIT){
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(15 == SPLIT){
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(16 == SPLIT){
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(17 == SPLIT){
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(18 == SPLIT){
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(19 == SPLIT){
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(20 == SPLIT){
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(21 == SPLIT){
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(22 == SPLIT){
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(23 == SPLIT){
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(24 == SPLIT){
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(25 == SPLIT){
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(26 == SPLIT){
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(27 == SPLIT){
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(28 == SPLIT){
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(29 == SPLIT){
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(30 == SPLIT){
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(31 == SPLIT){
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(32 == SPLIT){
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(33 == SPLIT){
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(34 == SPLIT){
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(35 == SPLIT){
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(36 == SPLIT){
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(37 == SPLIT){
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(38 == SPLIT){
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(39 == SPLIT){
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(40 == SPLIT){
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(41 == SPLIT){
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(42 == SPLIT){
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(43 == SPLIT){
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(44 == SPLIT){
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(45 == SPLIT){
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(46 == SPLIT){
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(47 == SPLIT){
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(48 == SPLIT){
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(49 == SPLIT){
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(50 == SPLIT){
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(51 == SPLIT){
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(52 == SPLIT){
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(53 == SPLIT){
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(54 == SPLIT){
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(55 == SPLIT){
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(56 == SPLIT){
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(57 == SPLIT){
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(58 == SPLIT){
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(59 == SPLIT){
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(60 == SPLIT){
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(61 == SPLIT){
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(62 == SPLIT){
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(63 == SPLIT){
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(64 == SPLIT){
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(65 == SPLIT){
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(66 == SPLIT){
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(67 == SPLIT){
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(68 == SPLIT){
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(69 == SPLIT){
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(70 == SPLIT){
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(71 == SPLIT){
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(72 == SPLIT){
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(73 == SPLIT){
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(74 == SPLIT){
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(75 == SPLIT){
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(76 == SPLIT){
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(77 == SPLIT){
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(78 == SPLIT){
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(79 == SPLIT){
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(80 == SPLIT){
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(81 == SPLIT){
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(82 == SPLIT){
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(83 == SPLIT){
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(84 == SPLIT){
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(85 == SPLIT){
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(86 == SPLIT){
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(87 == SPLIT){
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(88 == SPLIT){
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(89 == SPLIT){
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(90 == SPLIT){
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(91 == SPLIT){
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(92 == SPLIT){
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(93 == SPLIT){
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(94 == SPLIT){
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(95 == SPLIT){
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(96 == SPLIT){
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(97 == SPLIT){
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(98 == SPLIT){
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(99 == SPLIT){
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(100 == SPLIT){
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(101 == SPLIT){
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(102 == SPLIT){
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(103 == SPLIT){
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(104 == SPLIT){
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(105 == SPLIT){
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(106 == SPLIT){
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(107 == SPLIT){
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(108 == SPLIT){
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(109 == SPLIT){
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(110 == SPLIT){
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(111 == SPLIT){
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(112 == SPLIT){
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(113 == SPLIT){
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(114 == SPLIT){
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(115 == SPLIT){
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(116 == SPLIT){
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(117 == SPLIT){
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(118 == SPLIT){
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(119 == SPLIT){
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(120 == SPLIT){
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(121 == SPLIT){
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(122 == SPLIT){
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(123 == SPLIT){
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(124 == SPLIT){
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(125 == SPLIT){
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(126 == SPLIT){
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(127 == SPLIT){
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(128 == SPLIT){
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(129 == SPLIT){
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(130 == SPLIT){
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(131 == SPLIT){
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(132 == SPLIT){
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(133 == SPLIT){
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(134 == SPLIT){
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(135 == SPLIT){
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(136 == SPLIT){
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(137 == SPLIT){
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(138 == SPLIT){
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(139 == SPLIT){
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(140 == SPLIT){
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(141 == SPLIT){
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(142 == SPLIT){
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(143 == SPLIT){
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(144 == SPLIT){
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(145 == SPLIT){
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(146 == SPLIT){
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(147 == SPLIT){
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(148 == SPLIT){
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(149 == SPLIT){
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(150 == SPLIT){
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(151 == SPLIT){
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(152 == SPLIT){
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(153 == SPLIT){
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(154 == SPLIT){
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(155 == SPLIT){
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(156 == SPLIT){
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(157 == SPLIT){
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(158 == SPLIT){
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(159 == SPLIT){
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(160 == SPLIT){
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(161 == SPLIT){
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(162 == SPLIT){
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(163 == SPLIT){
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(164 == SPLIT){
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(165 == SPLIT){
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(166 == SPLIT){
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(167 == SPLIT){
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(168 == SPLIT){
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(169 == SPLIT){
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(170 == SPLIT){
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(171 == SPLIT){
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(172 == SPLIT){
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(173 == SPLIT){
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(174 == SPLIT){
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(175 == SPLIT){
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(176 == SPLIT){
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(177 == SPLIT){
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(178 == SPLIT){
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(179 == SPLIT){
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(180 == SPLIT){
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(181 == SPLIT){
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(182 == SPLIT){
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(183 == SPLIT){
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(184 == SPLIT){
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(185 == SPLIT){
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(186 == SPLIT){
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(187 == SPLIT){
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(188 == SPLIT){
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(189 == SPLIT){
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(190 == SPLIT){
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(191 == SPLIT){
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(192 == SPLIT){
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(193 == SPLIT){
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(194 == SPLIT){
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(195 == SPLIT){
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(196 == SPLIT){
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(197 == SPLIT){
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(198 == SPLIT){
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(199 == SPLIT){
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(200 == SPLIT){
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(201 == SPLIT){
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(202 == SPLIT){
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(203 == SPLIT){
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(204 == SPLIT){
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(205 == SPLIT){
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(206 == SPLIT){
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(207 == SPLIT){
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(208 == SPLIT){
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(209 == SPLIT){
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(210 == SPLIT){
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(211 == SPLIT){
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(212 == SPLIT){
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(213 == SPLIT){
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(214 == SPLIT){
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(215 == SPLIT){
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(216 == SPLIT){
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(217 == SPLIT){
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(218 == SPLIT){
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(219 == SPLIT){
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(220 == SPLIT){
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(221 == SPLIT){
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(222 == SPLIT){
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(223 == SPLIT){
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(224 == SPLIT){
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(225 == SPLIT){
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(226 == SPLIT){
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(227 == SPLIT){
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(228 == SPLIT){
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(229 == SPLIT){
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(230 == SPLIT){
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(231 == SPLIT){
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(232 == SPLIT){
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(233 == SPLIT){
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(234 == SPLIT){
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(235 == SPLIT){
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(236 == SPLIT){
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(237 == SPLIT){
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(238 == SPLIT){
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(239 == SPLIT){
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(240 == SPLIT){
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(241 == SPLIT){
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(242 == SPLIT){
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(243 == SPLIT){
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(244 == SPLIT){
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(245 == SPLIT){
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(246 == SPLIT){
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(247 == SPLIT){
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(248 == SPLIT){
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(249 == SPLIT){
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(250 == SPLIT){
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(251 == SPLIT){
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(252 == SPLIT){
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(253 == SPLIT){
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(254 == SPLIT){
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(255 == SPLIT){
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(256 == SPLIT){
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(257 == SPLIT){
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(258 == SPLIT){
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(259 == SPLIT){
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(260 == SPLIT){
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(261 == SPLIT){
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(262 == SPLIT){
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(263 == SPLIT){
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(264 == SPLIT){
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(265 == SPLIT){
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(266 == SPLIT){
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(267 == SPLIT){
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(268 == SPLIT){
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(269 == SPLIT){
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(270 == SPLIT){
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(271 == SPLIT){
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(272 == SPLIT){
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(273 == SPLIT){
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(274 == SPLIT){
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(275 == SPLIT){
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(276 == SPLIT){
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(277 == SPLIT){
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(278 == SPLIT){
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(279 == SPLIT){
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(280 == SPLIT){
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(281 == SPLIT){
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(282 == SPLIT){
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(283 == SPLIT){
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(284 == SPLIT){
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(285 == SPLIT){
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(286 == SPLIT){
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(287 == SPLIT){
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(288 == SPLIT){
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(289 == SPLIT){
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(290 == SPLIT){
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(291 == SPLIT){
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(292 == SPLIT){
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(293 == SPLIT){
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(294 == SPLIT){
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(295 == SPLIT){
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(296 == SPLIT){
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(297 == SPLIT){
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(298 == SPLIT){
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(299 == SPLIT){
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(300 == SPLIT){
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(301 == SPLIT){
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(302 == SPLIT){
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(303 == SPLIT){
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(304 == SPLIT){
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(305 == SPLIT){
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(306 == SPLIT){
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(307 == SPLIT){
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(308 == SPLIT){
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(309 == SPLIT){
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(310 == SPLIT){
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(311 == SPLIT){
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(312 == SPLIT){
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(313 == SPLIT){
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(314 == SPLIT){
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(315 == SPLIT){
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(316 == SPLIT){
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(317 == SPLIT){
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(318 == SPLIT){
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(319 == SPLIT){
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(320 == SPLIT){
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(321 == SPLIT){
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(322 == SPLIT){
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(323 == SPLIT){
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(324 == SPLIT){
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(325 == SPLIT){
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(326 == SPLIT){
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(327 == SPLIT){
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(328 == SPLIT){
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(329 == SPLIT){
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(330 == SPLIT){
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(331 == SPLIT){
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(332 == SPLIT){
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(333 == SPLIT){
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(334 == SPLIT){
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(335 == SPLIT){
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(336 == SPLIT){
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(337 == SPLIT){
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(338 == SPLIT){
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(339 == SPLIT){
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(340 == SPLIT){
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(341 == SPLIT){
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(342 == SPLIT){
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(343 == SPLIT){
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(344 == SPLIT){
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(345 == SPLIT){
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(346 == SPLIT){
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(347 == SPLIT){
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(348 == SPLIT){
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(349 == SPLIT){
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(350 == SPLIT){
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(351 == SPLIT){
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(352 == SPLIT){
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(353 == SPLIT){
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(354 == SPLIT){
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(355 == SPLIT){
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(356 == SPLIT){
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(357 == SPLIT){
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(358 == SPLIT){
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(359 == SPLIT){
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(360 == SPLIT){
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(361 == SPLIT){
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(362 == SPLIT){
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(363 == SPLIT){
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(364 == SPLIT){
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(365 == SPLIT){
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(366 == SPLIT){
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(367 == SPLIT){
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(368 == SPLIT){
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(369 == SPLIT){
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(370 == SPLIT){
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(371 == SPLIT){
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(372 == SPLIT){
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(373 == SPLIT){
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(374 == SPLIT){
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(375 == SPLIT){
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(376 == SPLIT){
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(377 == SPLIT){
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(378 == SPLIT){
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(379 == SPLIT){
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(380 == SPLIT){
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(381 == SPLIT){
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(382 == SPLIT){
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(383 == SPLIT){
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(384 == SPLIT){
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(385 == SPLIT){
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(386 == SPLIT){
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(387 == SPLIT){
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(388 == SPLIT){
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(389 == SPLIT){
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(390 == SPLIT){
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(391 == SPLIT){
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(392 == SPLIT){
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(393 == SPLIT){
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(394 == SPLIT){
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(395 == SPLIT){
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(396 == SPLIT){
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(397 == SPLIT){
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(398 == SPLIT){
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(399 == SPLIT){
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(400 == SPLIT){
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(401 == SPLIT){
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(402 == SPLIT){
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(403 == SPLIT){
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(404 == SPLIT){
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(405 == SPLIT){
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(406 == SPLIT){
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(407 == SPLIT){
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(408 == SPLIT){
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(409 == SPLIT){
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(410 == SPLIT){
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(411 == SPLIT){
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(412 == SPLIT){
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(413 == SPLIT){
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(414 == SPLIT){
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(415 == SPLIT){
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(416 == SPLIT){
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(417 == SPLIT){
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(418 == SPLIT){
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(419 == SPLIT){
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(420 == SPLIT){
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(421 == SPLIT){
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(422 == SPLIT){
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(423 == SPLIT){
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(424 == SPLIT){
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(425 == SPLIT){
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(426 == SPLIT){
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(427 == SPLIT){
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(428 == SPLIT){
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(429 == SPLIT){
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(430 == SPLIT){
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(431 == SPLIT){
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(432 == SPLIT){
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(433 == SPLIT){
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(434 == SPLIT){
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(435 == SPLIT){
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(436 == SPLIT){
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(437 == SPLIT){
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(438 == SPLIT){
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(439 == SPLIT){
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(440 == SPLIT){
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(441 == SPLIT){
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(442 == SPLIT){
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(443 == SPLIT){
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(444 == SPLIT){
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(445 == SPLIT){
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(446 == SPLIT){
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(447 == SPLIT){
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(448 == SPLIT){
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(449 == SPLIT){
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(450 == SPLIT){
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(451 == SPLIT){
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(452 == SPLIT){
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(453 == SPLIT){
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(454 == SPLIT){
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(455 == SPLIT){
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(456 == SPLIT){
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(457 == SPLIT){
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(458 == SPLIT){
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(459 == SPLIT){
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(460 == SPLIT){
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(461 == SPLIT){
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(462 == SPLIT){
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(463 == SPLIT){
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(464 == SPLIT){
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(465 == SPLIT){
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(466 == SPLIT){
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(467 == SPLIT){
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(468 == SPLIT){
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(469 == SPLIT){
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(470 == SPLIT){
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(471 == SPLIT){
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(472 == SPLIT){
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(473 == SPLIT){
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(474 == SPLIT){
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(475 == SPLIT){
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(476 == SPLIT){
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(477 == SPLIT){
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(478 == SPLIT){
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(479 == SPLIT){
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(480 == SPLIT){
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(481 == SPLIT){
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(482 == SPLIT){
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(483 == SPLIT){
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(484 == SPLIT){
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(485 == SPLIT){
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(486 == SPLIT){
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(487 == SPLIT){
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(488 == SPLIT){
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(489 == SPLIT){
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(490 == SPLIT){
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(491 == SPLIT){
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(492 == SPLIT){
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(493 == SPLIT){
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(494 == SPLIT){
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(495 == SPLIT){
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(496 == SPLIT){
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(497 == SPLIT){
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(498 == SPLIT){
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(499 == SPLIT){
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(500 == SPLIT){
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(501 == SPLIT){
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(502 == SPLIT){
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(503 == SPLIT){
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(504 == SPLIT){
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(505 == SPLIT){
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(506 == SPLIT){
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(507 == SPLIT){
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(508 == SPLIT){
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(509 == SPLIT){
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(510 == SPLIT){
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(511 == SPLIT){
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(512 == SPLIT){
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(513 == SPLIT){
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(514 == SPLIT){
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(515 == SPLIT){
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(516 == SPLIT){
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(517 == SPLIT){
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(518 == SPLIT){
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(519 == SPLIT){
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(520 == SPLIT){
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(521 == SPLIT){
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(522 == SPLIT){
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(523 == SPLIT){
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(524 == SPLIT){
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(525 == SPLIT){
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(526 == SPLIT){
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(527 == SPLIT){
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(528 == SPLIT){
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(529 == SPLIT){
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(530 == SPLIT){
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(531 == SPLIT){
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(532 == SPLIT){
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(533 == SPLIT){
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(534 == SPLIT){
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(535 == SPLIT){
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(536 == SPLIT){
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(537 == SPLIT){
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(538 == SPLIT){
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(539 == SPLIT){
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(540 == SPLIT){
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(541 == SPLIT){
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(542 == SPLIT){
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(543 == SPLIT){
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(544 == SPLIT){
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(545 == SPLIT){
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(546 == SPLIT){
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(547 == SPLIT){
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(548 == SPLIT){
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(549 == SPLIT){
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(550 == SPLIT){
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(551 == SPLIT){
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(552 == SPLIT){
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(553 == SPLIT){
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(554 == SPLIT){
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(555 == SPLIT){
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(556 == SPLIT){
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(557 == SPLIT){
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(558 == SPLIT){
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(559 == SPLIT){
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(560 == SPLIT){
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(561 == SPLIT){
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(562 == SPLIT){
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(563 == SPLIT){
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(564 == SPLIT){
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(565 == SPLIT){
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(566 == SPLIT){
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(567 == SPLIT){
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(568 == SPLIT){
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(569 == SPLIT){
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(570 == SPLIT){
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(571 == SPLIT){
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(572 == SPLIT){
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(573 == SPLIT){
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(574 == SPLIT){
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(575 == SPLIT){
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(576 == SPLIT){
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(577 == SPLIT){
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(578 == SPLIT){
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(579 == SPLIT){
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(580 == SPLIT){
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(581 == SPLIT){
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(582 == SPLIT){
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(583 == SPLIT){
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(584 == SPLIT){
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(585 == SPLIT){
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(586 == SPLIT){
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(587 == SPLIT){
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(588 == SPLIT){
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(589 == SPLIT){
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(590 == SPLIT){
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(591 == SPLIT){
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(592 == SPLIT){
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(593 == SPLIT){
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(594 == SPLIT){
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(595 == SPLIT){
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(596 == SPLIT){
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(597 == SPLIT){
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(598 == SPLIT){
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(599 == SPLIT){
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(600 == SPLIT){
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(601 == SPLIT){
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(602 == SPLIT){
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(603 == SPLIT){
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(604 == SPLIT){
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(605 == SPLIT){
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(606 == SPLIT){
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(607 == SPLIT){
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(608 == SPLIT){
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(609 == SPLIT){
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(610 == SPLIT){
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(611 == SPLIT){
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(612 == SPLIT){
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(613 == SPLIT){
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(614 == SPLIT){
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(615 == SPLIT){
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(616 == SPLIT){
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(617 == SPLIT){
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(618 == SPLIT){
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(619 == SPLIT){
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(620 == SPLIT){
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(621 == SPLIT){
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(622 == SPLIT){
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(623 == SPLIT){
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(624 == SPLIT){
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(625 == SPLIT){
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(626 == SPLIT){
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(627 == SPLIT){
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(628 == SPLIT){
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(629 == SPLIT){
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(630 == SPLIT){
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(631 == SPLIT){
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(632 == SPLIT){
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(633 == SPLIT){
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(634 == SPLIT){
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(635 == SPLIT){
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(636 == SPLIT){
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(637 == SPLIT){
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(638 == SPLIT){
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(639 == SPLIT){
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(640 == SPLIT){
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(641 == SPLIT){
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(642 == SPLIT){
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(643 == SPLIT){
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(644 == SPLIT){
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(645 == SPLIT){
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(646 == SPLIT){
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(647 == SPLIT){
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(648 == SPLIT){
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(649 == SPLIT){
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(650 == SPLIT){
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(651 == SPLIT){
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(652 == SPLIT){
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(653 == SPLIT){
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(654 == SPLIT){
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(655 == SPLIT){
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(656 == SPLIT){
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(657 == SPLIT){
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(658 == SPLIT){
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(659 == SPLIT){
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(660 == SPLIT){
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(661 == SPLIT){
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(662 == SPLIT){
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(663 == SPLIT){
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(664 == SPLIT){
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(665 == SPLIT){
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(666 == SPLIT){
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(667 == SPLIT){
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(668 == SPLIT){
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(669 == SPLIT){
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(670 == SPLIT){
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(671 == SPLIT){
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(672 == SPLIT){
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(673 == SPLIT){
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(674 == SPLIT){
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(675 == SPLIT){
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(676 == SPLIT){
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(677 == SPLIT){
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(678 == SPLIT){
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(679 == SPLIT){
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(680 == SPLIT){
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(681 == SPLIT){
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(682 == SPLIT){
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(683 == SPLIT){
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(684 == SPLIT){
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(685 == SPLIT){
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(686 == SPLIT){
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(687 == SPLIT){
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(688 == SPLIT){
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(689 == SPLIT){
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(690 == SPLIT){
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(691 == SPLIT){
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(692 == SPLIT){
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(693 == SPLIT){
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(694 == SPLIT){
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(695 == SPLIT){
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(696 == SPLIT){
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(697 == SPLIT){
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(698 == SPLIT){
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(699 == SPLIT){
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(700 == SPLIT){
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(701 == SPLIT){
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(702 == SPLIT){
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(703 == SPLIT){
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(704 == SPLIT){
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(705 == SPLIT){
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(706 == SPLIT){
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(707 == SPLIT){
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(708 == SPLIT){
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(709 == SPLIT){
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(710 == SPLIT){
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(711 == SPLIT){
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(712 == SPLIT){
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(713 == SPLIT){
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(714 == SPLIT){
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k0(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(715 == SPLIT){
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k1(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(716 == SPLIT){
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k2(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(717 == SPLIT){
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k3(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(718 == SPLIT){
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k4(A, size, order, dimensions);
			cout << endl;
		}

		}
		if(719 == SPLIT){
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k5(A, size, order, dimensions);
			cout << endl;
		}

		}
	free(A);
	free(dimensions);
}
