
#include <iostream>
#include "taco.h"
#include "taco/util/timers.h"
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <cmath>
#include <climits>

#include "taco/tensor.h"
#include "taco/format.h"
#include "taco/error.h"
#include "taco/util/strings.h"
#include "taco/util/files.h"
#include <cstdio>
#include <cstdlib>
#include <vector>


struct coo_t
{
	int32_t	idx0;
	int32_t	idx1;
	int32_t	idx2;
	int32_t	idx3;
	int32_t	idx4;
	double	val;
};


using namespace taco;
int cmp_01234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_34(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_4(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_01243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_43(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_3(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_01324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_24(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_01342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_42(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_2(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_01423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_23(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_01432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_32(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_02134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_02143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_02314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_14(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_02341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_41(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_1(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_02413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_13(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_02431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_31(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_03124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_03142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_03214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_03241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_03412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_12(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_03421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_21(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_04123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_04132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_04213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_04231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_04312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_04321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_10234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0234(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_10243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0243(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_10324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0324(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_10342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0342(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_10423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0423(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_10432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0432(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_12034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_12043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_12304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_04(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_12340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_40(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_0(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_12403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_03(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_12430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_30(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_13024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_13042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_13204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_13240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_13402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_02(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_13420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_20(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_14023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_14032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_14203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_14230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_14302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_14320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_20134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0134(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_20143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0143(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_20314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0314(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_20341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0341(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_20413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0413(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_20431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0431(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_21034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1034(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_21043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1043(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_21304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1304(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_21340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1340(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_21403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1403(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_21430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1430(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_23014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_23041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_23104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_3104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_23140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_23401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_01(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_23410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_10(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_24013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_24031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_24103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_4103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_24130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_24301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_24310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_30124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0124(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_30142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0142(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_30214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_0214(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_30241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0241(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_30412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0412(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_30421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0421(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_31024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1024(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_31042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1042(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_31204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_1204(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_31240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1240(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_31402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1402(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_31420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1420(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_32014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2014(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_32041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2041(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_32104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_2104(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	return 0;
}
int cmp_32140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2140(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_32401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2401(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_32410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2410(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_34012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_34021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_34102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_4102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_34120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_34201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_4201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_34210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_4210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_40123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0123(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_40132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0132(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_40213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_0213(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_40231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0231(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_40312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_0312(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_40321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_0321(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_41023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1023(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_41032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1032(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_41203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_1203(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_41230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1230(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_41302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_1302(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_41320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_1320(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_42013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2013(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_42031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2031(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_42103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_2103(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	return 0;
}
int cmp_42130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2130(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_42301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_2301(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_42310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_2310(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_43012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3012(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_43021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3021(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_43102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_3102(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	return 0;
}
int cmp_43120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3120(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_43201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_3201(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	return 0;
}
int cmp_43210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx4 < s->idx4) {
		return -1;
	} else if (r->idx4 > s->idx4) {
		return 1;
	}
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
int cmp_3210(const void *p, const void *q)
{
	struct coo_t * r = (struct coo_t *)p;
	struct coo_t * s = (struct coo_t *)q;
	if(r->idx3 < s->idx3) {
		return -1;
	} else if (r->idx3 > s->idx3) {
		return 1;
	}
	if(r->idx2 < s->idx2) {
		return -1;
	} else if (r->idx2 > s->idx2) {
		return 1;
	}
	if(r->idx1 < s->idx1) {
		return -1;
	} else if (r->idx1 > s->idx1) {
		return 1;
	}
	if(r->idx0 < s->idx0) {
		return -1;
	} else if (r->idx0 > s->idx0) {
		return 1;
	}
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	taco::util::Timer timer_0_cmp_01234;
	timer_0_cmp_01234.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01234);
	timer_0_cmp_01234.stop();
	taco::util::TimeResults res_0_cmp_01234 = timer_0_cmp_01234.getResult();
	cout << " | 0_cmp_01234 ";
	cout << " | "<< res_0_cmp_01234 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	taco::util::Timer timer_1_cmp_1234;
	timer_1_cmp_1234.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1234);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1234);
	timer_1_cmp_1234.stop();
	taco::util::TimeResults res_1_cmp_1234 = timer_1_cmp_1234.getResult();
	cout << " | 1_cmp_1234 ";
	cout << " | "<< res_1_cmp_1234 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	taco::util::Timer timer_2_cmp_234;
	timer_2_cmp_234.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_234);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_234);
	timer_2_cmp_234.stop();
	taco::util::TimeResults res_2_cmp_234 = timer_2_cmp_234.getResult();
	cout << " | 2_cmp_234 ";
	cout << " | "<< res_2_cmp_234 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	taco::util::Timer timer_3_cmp_34;
	timer_3_cmp_34.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_34);
	timer_3_cmp_34.stop();
	taco::util::TimeResults res_3_cmp_34 = timer_3_cmp_34.getResult();
	cout << " | 3_cmp_34 ";
	cout << " | "<< res_3_cmp_34 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 3, 4)
int transpose_coo_01234_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 3, 4)
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	taco::util::Timer timer_0_cmp_01243;
	timer_0_cmp_01243.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01243);
	timer_0_cmp_01243.stop();
	taco::util::TimeResults res_0_cmp_01243 = timer_0_cmp_01243.getResult();
	cout << " | 0_cmp_01243 ";
	cout << " | "<< res_0_cmp_01243 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	taco::util::Timer timer_1_cmp_1243;
	timer_1_cmp_1243.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1243);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1243);
	timer_1_cmp_1243.stop();
	taco::util::TimeResults res_1_cmp_1243 = timer_1_cmp_1243.getResult();
	cout << " | 1_cmp_1243 ";
	cout << " | "<< res_1_cmp_1243 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	taco::util::Timer timer_2_cmp_243;
	timer_2_cmp_243.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_243);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_243);
	timer_2_cmp_243.stop();
	taco::util::TimeResults res_2_cmp_243 = timer_2_cmp_243.getResult();
	cout << " | 2_cmp_243 ";
	cout << " | "<< res_2_cmp_243 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	taco::util::Timer timer_3_cmp_43;
	timer_3_cmp_43.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_43);
	timer_3_cmp_43.stop();
	taco::util::TimeResults res_3_cmp_43 = timer_3_cmp_43.getResult();
	cout << " | 3_cmp_43 ";
	cout << " | "<< res_3_cmp_43 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Fix and sort on [0, 1, 2]
	taco::util::Timer timer_4012;
	timer_4012.start();
	// Create buckets and quotient
	int *bucket_4012 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4012 = (int *)malloc(c_size*sizeof(int));
	int current_4012 = 0;
	bucket_4012[0] = 0;
	quotient_4012[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		bucket_4012[i] = current_4012;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4012[i];
		B4_count[idx4]--;
	}
	free(bucket_4012);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4012[perm[i]]] = C_coords_scratch[i];
		quotient_4012[perm[i]] ++;
	}
	free(quotient_4012);
	timer_4012.stop();
	taco::util::TimeResults res_4012 = timer_4012.getResult();
	cout << " , (4, [0, 1, 2]) ";
	cout << " , "<< res_4012 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 2, 4, 3)
int transpose_coo_01243_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 2, 4, 3)
	// Fix and sort on [0, 1, 2]
	taco::util::Timer timer_4012;
	timer_4012.start();
	// Create buckets and quotient
	int *bucket_4012 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4012 = (int *)malloc(c_size*sizeof(int));
	int current_4012 = 0;
	bucket_4012[0] = 0;
	quotient_4012[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4012++;
			quotient_4012[current_4012] = i;
		}
		bucket_4012[i] = current_4012;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4012[i];
		B4_count[idx4]--;
	}
	free(bucket_4012);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4012[perm[i]]] = C_coords_scratch[i];
		quotient_4012[perm[i]] ++;
	}
	free(quotient_4012);
	timer_4012.stop();
	taco::util::TimeResults res_4012 = timer_4012.getResult();
	cout << " , (4, [0, 1, 2]) ";
	cout << " , "<< res_4012 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	taco::util::Timer timer_0_cmp_01324;
	timer_0_cmp_01324.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01324);
	timer_0_cmp_01324.stop();
	taco::util::TimeResults res_0_cmp_01324 = timer_0_cmp_01324.getResult();
	cout << " | 0_cmp_01324 ";
	cout << " | "<< res_0_cmp_01324 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	taco::util::Timer timer_1_cmp_1324;
	timer_1_cmp_1324.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1324);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1324);
	timer_1_cmp_1324.stop();
	taco::util::TimeResults res_1_cmp_1324 = timer_1_cmp_1324.getResult();
	cout << " | 1_cmp_1324 ";
	cout << " | "<< res_1_cmp_1324 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	taco::util::Timer timer_2_cmp_324;
	timer_2_cmp_324.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_324);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_324);
	timer_2_cmp_324.stop();
	taco::util::TimeResults res_2_cmp_324 = timer_2_cmp_324.getResult();
	cout << " | 2_cmp_324 ";
	cout << " | "<< res_2_cmp_324 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	taco::util::Timer timer_3_cmp_24;
	timer_3_cmp_24.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_24);
	timer_3_cmp_24.stop();
	taco::util::TimeResults res_3_cmp_24 = timer_3_cmp_24.getResult();
	cout << " | 3_cmp_24 ";
	cout << " | "<< res_3_cmp_24 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 2, 4)
int transpose_coo_01324_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 2, 4)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	taco::util::Timer timer_0_cmp_01342;
	timer_0_cmp_01342.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01342);
	timer_0_cmp_01342.stop();
	taco::util::TimeResults res_0_cmp_01342 = timer_0_cmp_01342.getResult();
	cout << " | 0_cmp_01342 ";
	cout << " | "<< res_0_cmp_01342 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	taco::util::Timer timer_1_cmp_1342;
	timer_1_cmp_1342.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1342);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1342);
	timer_1_cmp_1342.stop();
	taco::util::TimeResults res_1_cmp_1342 = timer_1_cmp_1342.getResult();
	cout << " | 1_cmp_1342 ";
	cout << " | "<< res_1_cmp_1342 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	taco::util::Timer timer_2_cmp_342;
	timer_2_cmp_342.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_342);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_342);
	timer_2_cmp_342.stop();
	taco::util::TimeResults res_2_cmp_342 = timer_2_cmp_342.getResult();
	cout << " | 2_cmp_342 ";
	cout << " | "<< res_2_cmp_342 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	taco::util::Timer timer_3_cmp_42;
	timer_3_cmp_42.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_42);
	timer_3_cmp_42.stop();
	taco::util::TimeResults res_3_cmp_42 = timer_3_cmp_42.getResult();
	cout << " | 3_cmp_42 ";
	cout << " | "<< res_3_cmp_42 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 3, 4, 2)
int transpose_coo_01342_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 3, 4, 2)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	taco::util::Timer timer_0_cmp_01423;
	timer_0_cmp_01423.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01423);
	timer_0_cmp_01423.stop();
	taco::util::TimeResults res_0_cmp_01423 = timer_0_cmp_01423.getResult();
	cout << " | 0_cmp_01423 ";
	cout << " | "<< res_0_cmp_01423 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	taco::util::Timer timer_1_cmp_1423;
	timer_1_cmp_1423.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1423);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1423);
	timer_1_cmp_1423.stop();
	taco::util::TimeResults res_1_cmp_1423 = timer_1_cmp_1423.getResult();
	cout << " | 1_cmp_1423 ";
	cout << " | "<< res_1_cmp_1423 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	taco::util::Timer timer_2_cmp_423;
	timer_2_cmp_423.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_423);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_423);
	timer_2_cmp_423.stop();
	taco::util::TimeResults res_2_cmp_423 = timer_2_cmp_423.getResult();
	cout << " | 2_cmp_423 ";
	cout << " | "<< res_2_cmp_423 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	taco::util::Timer timer_3_cmp_23;
	timer_3_cmp_23.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_23);
	timer_3_cmp_23.stop();
	taco::util::TimeResults res_3_cmp_23 = timer_3_cmp_23.getResult();
	cout << " | 3_cmp_23 ";
	cout << " | "<< res_3_cmp_23 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 2, 3)
int transpose_coo_01423_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 2, 3)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	taco::util::Timer timer_0_cmp_01432;
	timer_0_cmp_01432.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_01432);
	timer_0_cmp_01432.stop();
	taco::util::TimeResults res_0_cmp_01432 = timer_0_cmp_01432.getResult();
	cout << " | 0_cmp_01432 ";
	cout << " | "<< res_0_cmp_01432 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	taco::util::Timer timer_1_cmp_1432;
	timer_1_cmp_1432.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1432);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1432);
	timer_1_cmp_1432.stop();
	taco::util::TimeResults res_1_cmp_1432 = timer_1_cmp_1432.getResult();
	cout << " | 1_cmp_1432 ";
	cout << " | "<< res_1_cmp_1432 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	taco::util::Timer timer_2_cmp_432;
	timer_2_cmp_432.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_432);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_432);
	timer_2_cmp_432.stop();
	taco::util::TimeResults res_2_cmp_432 = timer_2_cmp_432.getResult();
	cout << " | 2_cmp_432 ";
	cout << " | "<< res_2_cmp_432 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	taco::util::Timer timer_3_cmp_32;
	timer_3_cmp_32.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_32);
	timer_3_cmp_32.stop();
	taco::util::TimeResults res_3_cmp_32 = timer_3_cmp_32.getResult();
	cout << " | 3_cmp_32 ";
	cout << " | "<< res_3_cmp_32 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 1, 4, 3, 2)
int transpose_coo_01432_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 1, 4, 3, 2)
	// Fix and sort on [0, 1]
	taco::util::Timer timer_301;
	timer_301.start();
	// Create buckets and quotient
	int *bucket_301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_301 = (int *)malloc(c_size*sizeof(int));
	int current_301 = 0;
	bucket_301[0] = 0;
	quotient_301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_301++;
			quotient_301[current_301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_301++;
			quotient_301[current_301] = i;
		}
		bucket_301[i] = current_301;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_301[i];
		B3_count[idx3]--;
	}
	free(bucket_301);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_301[perm[i]]] = C_coords_scratch[i];
		quotient_301[perm[i]] ++;
	}
	free(quotient_301);
	timer_301.stop();
	taco::util::TimeResults res_301 = timer_301.getResult();
	cout << " , (3, [0, 1]) ";
	cout << " , "<< res_301 ;
	// Fix and sort on [0, 1]
	taco::util::Timer timer_401;
	timer_401.start();
	// Create buckets and quotient
	int *bucket_401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_401 = (int *)malloc(c_size*sizeof(int));
	int current_401 = 0;
	bucket_401[0] = 0;
	quotient_401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_401++;
			quotient_401[current_401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_401++;
			quotient_401[current_401] = i;
		}
		bucket_401[i] = current_401;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_401[i];
		B4_count[idx4]--;
	}
	free(bucket_401);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_401[perm[i]]] = C_coords_scratch[i];
		quotient_401[perm[i]] ++;
	}
	free(quotient_401);
	timer_401.stop();
	taco::util::TimeResults res_401 = timer_401.getResult();
	cout << " , (4, [0, 1]) ";
	cout << " , "<< res_401 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	taco::util::Timer timer_0_cmp_02134;
	timer_0_cmp_02134.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02134);
	timer_0_cmp_02134.stop();
	taco::util::TimeResults res_0_cmp_02134 = timer_0_cmp_02134.getResult();
	cout << " | 0_cmp_02134 ";
	cout << " | "<< res_0_cmp_02134 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	taco::util::Timer timer_1_cmp_2134;
	timer_1_cmp_2134.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2134);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2134);
	timer_1_cmp_2134.stop();
	taco::util::TimeResults res_1_cmp_2134 = timer_1_cmp_2134.getResult();
	cout << " | 1_cmp_2134 ";
	cout << " | "<< res_1_cmp_2134 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_2_cmp_134;
	timer_2_cmp_134.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_134);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_134);
	timer_2_cmp_134.stop();
	taco::util::TimeResults res_2_cmp_134 = timer_2_cmp_134.getResult();
	cout << " | 2_cmp_134 ";
	cout << " | "<< res_2_cmp_134 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_3_cmp_34;
	timer_3_cmp_34.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_34);
	timer_3_cmp_34.stop();
	taco::util::TimeResults res_3_cmp_34 = timer_3_cmp_34.getResult();
	cout << " | 3_cmp_34 ";
	cout << " | "<< res_3_cmp_34 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 3, 4)
int transpose_coo_02134_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 3, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	taco::util::Timer timer_0_cmp_02143;
	timer_0_cmp_02143.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02143);
	timer_0_cmp_02143.stop();
	taco::util::TimeResults res_0_cmp_02143 = timer_0_cmp_02143.getResult();
	cout << " | 0_cmp_02143 ";
	cout << " | "<< res_0_cmp_02143 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	taco::util::Timer timer_1_cmp_2143;
	timer_1_cmp_2143.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2143);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2143);
	timer_1_cmp_2143.stop();
	taco::util::TimeResults res_1_cmp_2143 = timer_1_cmp_2143.getResult();
	cout << " | 1_cmp_2143 ";
	cout << " | "<< res_1_cmp_2143 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_2_cmp_143;
	timer_2_cmp_143.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_143);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_143);
	timer_2_cmp_143.stop();
	taco::util::TimeResults res_2_cmp_143 = timer_2_cmp_143.getResult();
	cout << " | 2_cmp_143 ";
	cout << " | "<< res_2_cmp_143 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_3_cmp_43;
	timer_3_cmp_43.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_43);
	timer_3_cmp_43.stop();
	taco::util::TimeResults res_3_cmp_43 = timer_3_cmp_43.getResult();
	cout << " | 3_cmp_43 ";
	cout << " | "<< res_3_cmp_43 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0, 2, 1]
	taco::util::Timer timer_4021;
	timer_4021.start();
	// Create buckets and quotient
	int *bucket_4021 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4021 = (int *)malloc(c_size*sizeof(int));
	int current_4021 = 0;
	bucket_4021[0] = 0;
	quotient_4021[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		bucket_4021[i] = current_4021;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4021[i];
		B4_count[idx4]--;
	}
	free(bucket_4021);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4021[perm[i]]] = C_coords_scratch[i];
		quotient_4021[perm[i]] ++;
	}
	free(quotient_4021);
	timer_4021.stop();
	taco::util::TimeResults res_4021 = timer_4021.getResult();
	cout << " , (4, [0, 2, 1]) ";
	cout << " , "<< res_4021 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 1, 4, 3)
int transpose_coo_02143_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 1, 4, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0, 2, 1]
	taco::util::Timer timer_4021;
	timer_4021.start();
	// Create buckets and quotient
	int *bucket_4021 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4021 = (int *)malloc(c_size*sizeof(int));
	int current_4021 = 0;
	bucket_4021[0] = 0;
	quotient_4021[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4021++;
			quotient_4021[current_4021] = i;
		}
		bucket_4021[i] = current_4021;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4021[i];
		B4_count[idx4]--;
	}
	free(bucket_4021);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4021[perm[i]]] = C_coords_scratch[i];
		quotient_4021[perm[i]] ++;
	}
	free(quotient_4021);
	timer_4021.stop();
	taco::util::TimeResults res_4021 = timer_4021.getResult();
	cout << " , (4, [0, 2, 1]) ";
	cout << " , "<< res_4021 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	taco::util::Timer timer_0_cmp_02314;
	timer_0_cmp_02314.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02314);
	timer_0_cmp_02314.stop();
	taco::util::TimeResults res_0_cmp_02314 = timer_0_cmp_02314.getResult();
	cout << " | 0_cmp_02314 ";
	cout << " | "<< res_0_cmp_02314 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	taco::util::Timer timer_1_cmp_2314;
	timer_1_cmp_2314.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2314);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2314);
	timer_1_cmp_2314.stop();
	taco::util::TimeResults res_1_cmp_2314 = timer_1_cmp_2314.getResult();
	cout << " | 1_cmp_2314 ";
	cout << " | "<< res_1_cmp_2314 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_2_cmp_314;
	timer_2_cmp_314.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_314);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_314);
	timer_2_cmp_314.stop();
	taco::util::TimeResults res_2_cmp_314 = timer_2_cmp_314.getResult();
	cout << " | 2_cmp_314 ";
	cout << " | "<< res_2_cmp_314 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_3_cmp_14;
	timer_3_cmp_14.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_14);
	timer_3_cmp_14.stop();
	taco::util::TimeResults res_3_cmp_14 = timer_3_cmp_14.getResult();
	cout << " | 3_cmp_14 ";
	cout << " | "<< res_3_cmp_14 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 1, 4)
int transpose_coo_02314_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	taco::util::Timer timer_0_cmp_02341;
	timer_0_cmp_02341.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02341);
	timer_0_cmp_02341.stop();
	taco::util::TimeResults res_0_cmp_02341 = timer_0_cmp_02341.getResult();
	cout << " | 0_cmp_02341 ";
	cout << " | "<< res_0_cmp_02341 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	taco::util::Timer timer_1_cmp_2341;
	timer_1_cmp_2341.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2341);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2341);
	timer_1_cmp_2341.stop();
	taco::util::TimeResults res_1_cmp_2341 = timer_1_cmp_2341.getResult();
	cout << " | 1_cmp_2341 ";
	cout << " | "<< res_1_cmp_2341 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_2_cmp_341;
	timer_2_cmp_341.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_341);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_341);
	timer_2_cmp_341.stop();
	taco::util::TimeResults res_2_cmp_341 = timer_2_cmp_341.getResult();
	cout << " | 2_cmp_341 ";
	cout << " | "<< res_2_cmp_341 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_3_cmp_41;
	timer_3_cmp_41.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_41);
	timer_3_cmp_41.stop();
	taco::util::TimeResults res_3_cmp_41 = timer_3_cmp_41.getResult();
	cout << " | 3_cmp_41 ";
	cout << " | "<< res_3_cmp_41 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 3, 4, 1)
int transpose_coo_02341_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 3, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	taco::util::Timer timer_0_cmp_02413;
	timer_0_cmp_02413.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02413);
	timer_0_cmp_02413.stop();
	taco::util::TimeResults res_0_cmp_02413 = timer_0_cmp_02413.getResult();
	cout << " | 0_cmp_02413 ";
	cout << " | "<< res_0_cmp_02413 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	taco::util::Timer timer_1_cmp_2413;
	timer_1_cmp_2413.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2413);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2413);
	timer_1_cmp_2413.stop();
	taco::util::TimeResults res_1_cmp_2413 = timer_1_cmp_2413.getResult();
	cout << " | 1_cmp_2413 ";
	cout << " | "<< res_1_cmp_2413 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_2_cmp_413;
	timer_2_cmp_413.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_413);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_413);
	timer_2_cmp_413.stop();
	taco::util::TimeResults res_2_cmp_413 = timer_2_cmp_413.getResult();
	cout << " | 2_cmp_413 ";
	cout << " | "<< res_2_cmp_413 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_3_cmp_13;
	timer_3_cmp_13.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_13);
	timer_3_cmp_13.stop();
	taco::util::TimeResults res_3_cmp_13 = timer_3_cmp_13.getResult();
	cout << " | 3_cmp_13 ";
	cout << " | "<< res_3_cmp_13 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 1, 3)
int transpose_coo_02413_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	taco::util::Timer timer_0_cmp_02431;
	timer_0_cmp_02431.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_02431);
	timer_0_cmp_02431.stop();
	taco::util::TimeResults res_0_cmp_02431 = timer_0_cmp_02431.getResult();
	cout << " | 0_cmp_02431 ";
	cout << " | "<< res_0_cmp_02431 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	taco::util::Timer timer_1_cmp_2431;
	timer_1_cmp_2431.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2431);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2431);
	timer_1_cmp_2431.stop();
	taco::util::TimeResults res_1_cmp_2431 = timer_1_cmp_2431.getResult();
	cout << " | 1_cmp_2431 ";
	cout << " | "<< res_1_cmp_2431 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_2_cmp_431;
	timer_2_cmp_431.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_431);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_431);
	timer_2_cmp_431.stop();
	taco::util::TimeResults res_2_cmp_431 = timer_2_cmp_431.getResult();
	cout << " | 2_cmp_431 ";
	cout << " | "<< res_2_cmp_431 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_3_cmp_31;
	timer_3_cmp_31.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_31);
	timer_3_cmp_31.stop();
	taco::util::TimeResults res_3_cmp_31 = timer_3_cmp_31.getResult();
	cout << " | 3_cmp_31 ";
	cout << " | "<< res_3_cmp_31 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 2, 4, 3, 1)
int transpose_coo_02431_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 2, 4, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	taco::util::Timer timer_0_cmp_03124;
	timer_0_cmp_03124.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03124);
	timer_0_cmp_03124.stop();
	taco::util::TimeResults res_0_cmp_03124 = timer_0_cmp_03124.getResult();
	cout << " | 0_cmp_03124 ";
	cout << " | "<< res_0_cmp_03124 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	taco::util::Timer timer_1_cmp_3124;
	timer_1_cmp_3124.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3124);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3124);
	timer_1_cmp_3124.stop();
	taco::util::TimeResults res_1_cmp_3124 = timer_1_cmp_3124.getResult();
	cout << " | 1_cmp_3124 ";
	cout << " | "<< res_1_cmp_3124 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_2_cmp_124;
	timer_2_cmp_124.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_124);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_124);
	timer_2_cmp_124.stop();
	taco::util::TimeResults res_2_cmp_124 = timer_2_cmp_124.getResult();
	cout << " | 2_cmp_124 ";
	cout << " | "<< res_2_cmp_124 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_3_cmp_24;
	timer_3_cmp_24.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_24);
	timer_3_cmp_24.stop();
	taco::util::TimeResults res_3_cmp_24 = timer_3_cmp_24.getResult();
	cout << " | 3_cmp_24 ";
	cout << " | "<< res_3_cmp_24 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 2, 4)
int transpose_coo_03124_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 2, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	taco::util::Timer timer_0_cmp_03142;
	timer_0_cmp_03142.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03142);
	timer_0_cmp_03142.stop();
	taco::util::TimeResults res_0_cmp_03142 = timer_0_cmp_03142.getResult();
	cout << " | 0_cmp_03142 ";
	cout << " | "<< res_0_cmp_03142 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	taco::util::Timer timer_1_cmp_3142;
	timer_1_cmp_3142.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3142);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3142);
	timer_1_cmp_3142.stop();
	taco::util::TimeResults res_1_cmp_3142 = timer_1_cmp_3142.getResult();
	cout << " | 1_cmp_3142 ";
	cout << " | "<< res_1_cmp_3142 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_2_cmp_142;
	timer_2_cmp_142.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_142);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_142);
	timer_2_cmp_142.stop();
	taco::util::TimeResults res_2_cmp_142 = timer_2_cmp_142.getResult();
	cout << " | 2_cmp_142 ";
	cout << " | "<< res_2_cmp_142 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_3_cmp_42;
	timer_3_cmp_42.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_42);
	timer_3_cmp_42.stop();
	taco::util::TimeResults res_3_cmp_42 = timer_3_cmp_42.getResult();
	cout << " | 3_cmp_42 ";
	cout << " | "<< res_3_cmp_42 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0, 3, 1]
	taco::util::Timer timer_4031;
	timer_4031.start();
	// Create buckets and quotient
	int *bucket_4031 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4031 = (int *)malloc(c_size*sizeof(int));
	int current_4031 = 0;
	bucket_4031[0] = 0;
	quotient_4031[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		bucket_4031[i] = current_4031;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4031[i];
		B4_count[idx4]--;
	}
	free(bucket_4031);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4031[perm[i]]] = C_coords_scratch[i];
		quotient_4031[perm[i]] ++;
	}
	free(quotient_4031);
	timer_4031.stop();
	taco::util::TimeResults res_4031 = timer_4031.getResult();
	cout << " , (4, [0, 3, 1]) ";
	cout << " , "<< res_4031 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 1, 4, 2)
int transpose_coo_03142_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 1, 4, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0, 3, 1]
	taco::util::Timer timer_4031;
	timer_4031.start();
	// Create buckets and quotient
	int *bucket_4031 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4031 = (int *)malloc(c_size*sizeof(int));
	int current_4031 = 0;
	bucket_4031[0] = 0;
	quotient_4031[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4031++;
			quotient_4031[current_4031] = i;
		}
		bucket_4031[i] = current_4031;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4031[i];
		B4_count[idx4]--;
	}
	free(bucket_4031);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4031[perm[i]]] = C_coords_scratch[i];
		quotient_4031[perm[i]] ++;
	}
	free(quotient_4031);
	timer_4031.stop();
	taco::util::TimeResults res_4031 = timer_4031.getResult();
	cout << " , (4, [0, 3, 1]) ";
	cout << " , "<< res_4031 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	taco::util::Timer timer_0_cmp_03214;
	timer_0_cmp_03214.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03214);
	timer_0_cmp_03214.stop();
	taco::util::TimeResults res_0_cmp_03214 = timer_0_cmp_03214.getResult();
	cout << " | 0_cmp_03214 ";
	cout << " | "<< res_0_cmp_03214 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	taco::util::Timer timer_1_cmp_3214;
	timer_1_cmp_3214.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3214);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3214);
	timer_1_cmp_3214.stop();
	taco::util::TimeResults res_1_cmp_3214 = timer_1_cmp_3214.getResult();
	cout << " | 1_cmp_3214 ";
	cout << " | "<< res_1_cmp_3214 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_2_cmp_214;
	timer_2_cmp_214.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_214);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_214);
	timer_2_cmp_214.stop();
	taco::util::TimeResults res_2_cmp_214 = timer_2_cmp_214.getResult();
	cout << " | 2_cmp_214 ";
	cout << " | "<< res_2_cmp_214 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_3_cmp_14;
	timer_3_cmp_14.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_14);
	timer_3_cmp_14.stop();
	taco::util::TimeResults res_3_cmp_14 = timer_3_cmp_14.getResult();
	cout << " | 3_cmp_14 ";
	cout << " | "<< res_3_cmp_14 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 1, 4)
int transpose_coo_03214_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 1, 4)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	taco::util::Timer timer_0_cmp_03241;
	timer_0_cmp_03241.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03241);
	timer_0_cmp_03241.stop();
	taco::util::TimeResults res_0_cmp_03241 = timer_0_cmp_03241.getResult();
	cout << " | 0_cmp_03241 ";
	cout << " | "<< res_0_cmp_03241 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	taco::util::Timer timer_1_cmp_3241;
	timer_1_cmp_3241.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3241);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3241);
	timer_1_cmp_3241.stop();
	taco::util::TimeResults res_1_cmp_3241 = timer_1_cmp_3241.getResult();
	cout << " | 1_cmp_3241 ";
	cout << " | "<< res_1_cmp_3241 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_2_cmp_241;
	timer_2_cmp_241.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_241);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_241);
	timer_2_cmp_241.stop();
	taco::util::TimeResults res_2_cmp_241 = timer_2_cmp_241.getResult();
	cout << " | 2_cmp_241 ";
	cout << " | "<< res_2_cmp_241 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_3_cmp_41;
	timer_3_cmp_41.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_41);
	timer_3_cmp_41.stop();
	taco::util::TimeResults res_3_cmp_41 = timer_3_cmp_41.getResult();
	cout << " | 3_cmp_41 ";
	cout << " | "<< res_3_cmp_41 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 2, 4, 1)
int transpose_coo_03241_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 2, 4, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	taco::util::Timer timer_0_cmp_03412;
	timer_0_cmp_03412.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03412);
	timer_0_cmp_03412.stop();
	taco::util::TimeResults res_0_cmp_03412 = timer_0_cmp_03412.getResult();
	cout << " | 0_cmp_03412 ";
	cout << " | "<< res_0_cmp_03412 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	taco::util::Timer timer_1_cmp_3412;
	timer_1_cmp_3412.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3412);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3412);
	timer_1_cmp_3412.stop();
	taco::util::TimeResults res_1_cmp_3412 = timer_1_cmp_3412.getResult();
	cout << " | 1_cmp_3412 ";
	cout << " | "<< res_1_cmp_3412 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_2_cmp_412;
	timer_2_cmp_412.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_412);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_412);
	timer_2_cmp_412.stop();
	taco::util::TimeResults res_2_cmp_412 = timer_2_cmp_412.getResult();
	cout << " | 2_cmp_412 ";
	cout << " | "<< res_2_cmp_412 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_3_cmp_12;
	timer_3_cmp_12.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_12);
	timer_3_cmp_12.stop();
	taco::util::TimeResults res_3_cmp_12 = timer_3_cmp_12.getResult();
	cout << " | 3_cmp_12 ";
	cout << " | "<< res_3_cmp_12 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 1, 2)
int transpose_coo_03412_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	taco::util::Timer timer_0_cmp_03421;
	timer_0_cmp_03421.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_03421);
	timer_0_cmp_03421.stop();
	taco::util::TimeResults res_0_cmp_03421 = timer_0_cmp_03421.getResult();
	cout << " | 0_cmp_03421 ";
	cout << " | "<< res_0_cmp_03421 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	taco::util::Timer timer_1_cmp_3421;
	timer_1_cmp_3421.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3421);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3421);
	timer_1_cmp_3421.stop();
	taco::util::TimeResults res_1_cmp_3421 = timer_1_cmp_3421.getResult();
	cout << " | 1_cmp_3421 ";
	cout << " | "<< res_1_cmp_3421 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_2_cmp_421;
	timer_2_cmp_421.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_421);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_421);
	timer_2_cmp_421.stop();
	taco::util::TimeResults res_2_cmp_421 = timer_2_cmp_421.getResult();
	cout << " | 2_cmp_421 ";
	cout << " | "<< res_2_cmp_421 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_3_cmp_21;
	timer_3_cmp_21.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_21);
	timer_3_cmp_21.stop();
	taco::util::TimeResults res_3_cmp_21 = timer_3_cmp_21.getResult();
	cout << " | 3_cmp_21 ";
	cout << " | "<< res_3_cmp_21 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 3, 4, 2, 1)
int transpose_coo_03421_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 3, 4, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	taco::util::Timer timer_0_cmp_04123;
	timer_0_cmp_04123.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04123);
	timer_0_cmp_04123.stop();
	taco::util::TimeResults res_0_cmp_04123 = timer_0_cmp_04123.getResult();
	cout << " | 0_cmp_04123 ";
	cout << " | "<< res_0_cmp_04123 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	taco::util::Timer timer_1_cmp_4123;
	timer_1_cmp_4123.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4123);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4123);
	timer_1_cmp_4123.stop();
	taco::util::TimeResults res_1_cmp_4123 = timer_1_cmp_4123.getResult();
	cout << " | 1_cmp_4123 ";
	cout << " | "<< res_1_cmp_4123 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_2_cmp_123;
	timer_2_cmp_123.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_123);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_123);
	timer_2_cmp_123.stop();
	taco::util::TimeResults res_2_cmp_123 = timer_2_cmp_123.getResult();
	cout << " | 2_cmp_123 ";
	cout << " | "<< res_2_cmp_123 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_3_cmp_23;
	timer_3_cmp_23.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_23);
	timer_3_cmp_23.stop();
	taco::util::TimeResults res_3_cmp_23 = timer_3_cmp_23.getResult();
	cout << " | 3_cmp_23 ";
	cout << " | "<< res_3_cmp_23 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 2, 3)
int transpose_coo_04123_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 2, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	taco::util::Timer timer_0_cmp_04132;
	timer_0_cmp_04132.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04132);
	timer_0_cmp_04132.stop();
	taco::util::TimeResults res_0_cmp_04132 = timer_0_cmp_04132.getResult();
	cout << " | 0_cmp_04132 ";
	cout << " | "<< res_0_cmp_04132 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	taco::util::Timer timer_1_cmp_4132;
	timer_1_cmp_4132.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4132);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4132);
	timer_1_cmp_4132.stop();
	taco::util::TimeResults res_1_cmp_4132 = timer_1_cmp_4132.getResult();
	cout << " | 1_cmp_4132 ";
	cout << " | "<< res_1_cmp_4132 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_2_cmp_132;
	timer_2_cmp_132.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_132);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_132);
	timer_2_cmp_132.stop();
	taco::util::TimeResults res_2_cmp_132 = timer_2_cmp_132.getResult();
	cout << " | 2_cmp_132 ";
	cout << " | "<< res_2_cmp_132 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_3_cmp_32;
	timer_3_cmp_32.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_32);
	timer_3_cmp_32.stop();
	taco::util::TimeResults res_3_cmp_32 = timer_3_cmp_32.getResult();
	cout << " | 3_cmp_32 ";
	cout << " | "<< res_3_cmp_32 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0, 4, 1]
	taco::util::Timer timer_3041;
	timer_3041.start();
	// Create buckets and quotient
	int *bucket_3041 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3041 = (int *)malloc(c_size*sizeof(int));
	int current_3041 = 0;
	bucket_3041[0] = 0;
	quotient_3041[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		bucket_3041[i] = current_3041;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3041[i];
		B3_count[idx3]--;
	}
	free(bucket_3041);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3041[perm[i]]] = C_coords_scratch[i];
		quotient_3041[perm[i]] ++;
	}
	free(quotient_3041);
	timer_3041.stop();
	taco::util::TimeResults res_3041 = timer_3041.getResult();
	cout << " , (3, [0, 4, 1]) ";
	cout << " , "<< res_3041 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 1, 3, 2)
int transpose_coo_04132_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 1, 3, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Fix and sort on [0, 4, 1]
	taco::util::Timer timer_3041;
	timer_3041.start();
	// Create buckets and quotient
	int *bucket_3041 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3041 = (int *)malloc(c_size*sizeof(int));
	int current_3041 = 0;
	bucket_3041[0] = 0;
	quotient_3041[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3041++;
			quotient_3041[current_3041] = i;
		}
		bucket_3041[i] = current_3041;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3041[i];
		B3_count[idx3]--;
	}
	free(bucket_3041);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3041[perm[i]]] = C_coords_scratch[i];
		quotient_3041[perm[i]] ++;
	}
	free(quotient_3041);
	timer_3041.stop();
	taco::util::TimeResults res_3041 = timer_3041.getResult();
	cout << " , (3, [0, 4, 1]) ";
	cout << " , "<< res_3041 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	taco::util::Timer timer_0_cmp_04213;
	timer_0_cmp_04213.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04213);
	timer_0_cmp_04213.stop();
	taco::util::TimeResults res_0_cmp_04213 = timer_0_cmp_04213.getResult();
	cout << " | 0_cmp_04213 ";
	cout << " | "<< res_0_cmp_04213 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	taco::util::Timer timer_1_cmp_4213;
	timer_1_cmp_4213.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4213);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4213);
	timer_1_cmp_4213.stop();
	taco::util::TimeResults res_1_cmp_4213 = timer_1_cmp_4213.getResult();
	cout << " | 1_cmp_4213 ";
	cout << " | "<< res_1_cmp_4213 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_2_cmp_213;
	timer_2_cmp_213.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_213);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_213);
	timer_2_cmp_213.stop();
	taco::util::TimeResults res_2_cmp_213 = timer_2_cmp_213.getResult();
	cout << " | 2_cmp_213 ";
	cout << " | "<< res_2_cmp_213 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_3_cmp_13;
	timer_3_cmp_13.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_13);
	timer_3_cmp_13.stop();
	taco::util::TimeResults res_3_cmp_13 = timer_3_cmp_13.getResult();
	cout << " | 3_cmp_13 ";
	cout << " | "<< res_3_cmp_13 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 1, 3)
int transpose_coo_04213_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 1, 3)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	taco::util::Timer timer_0_cmp_04231;
	timer_0_cmp_04231.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04231);
	timer_0_cmp_04231.stop();
	taco::util::TimeResults res_0_cmp_04231 = timer_0_cmp_04231.getResult();
	cout << " | 0_cmp_04231 ";
	cout << " | "<< res_0_cmp_04231 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	taco::util::Timer timer_1_cmp_4231;
	timer_1_cmp_4231.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4231);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4231);
	timer_1_cmp_4231.stop();
	taco::util::TimeResults res_1_cmp_4231 = timer_1_cmp_4231.getResult();
	cout << " | 1_cmp_4231 ";
	cout << " | "<< res_1_cmp_4231 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_2_cmp_231;
	timer_2_cmp_231.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_231);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_231);
	timer_2_cmp_231.stop();
	taco::util::TimeResults res_2_cmp_231 = timer_2_cmp_231.getResult();
	cout << " | 2_cmp_231 ";
	cout << " | "<< res_2_cmp_231 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_3_cmp_31;
	timer_3_cmp_31.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_31);
	timer_3_cmp_31.stop();
	taco::util::TimeResults res_3_cmp_31 = timer_3_cmp_31.getResult();
	cout << " | 3_cmp_31 ";
	cout << " | "<< res_3_cmp_31 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 2, 3, 1)
int transpose_coo_04231_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 2, 3, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	taco::util::Timer timer_0_cmp_04312;
	timer_0_cmp_04312.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04312);
	timer_0_cmp_04312.stop();
	taco::util::TimeResults res_0_cmp_04312 = timer_0_cmp_04312.getResult();
	cout << " | 0_cmp_04312 ";
	cout << " | "<< res_0_cmp_04312 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	taco::util::Timer timer_1_cmp_4312;
	timer_1_cmp_4312.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4312);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4312);
	timer_1_cmp_4312.stop();
	taco::util::TimeResults res_1_cmp_4312 = timer_1_cmp_4312.getResult();
	cout << " | 1_cmp_4312 ";
	cout << " | "<< res_1_cmp_4312 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_2_cmp_312;
	timer_2_cmp_312.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_312);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_312);
	timer_2_cmp_312.stop();
	taco::util::TimeResults res_2_cmp_312 = timer_2_cmp_312.getResult();
	cout << " | 2_cmp_312 ";
	cout << " | "<< res_2_cmp_312 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_3_cmp_12;
	timer_3_cmp_12.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_12);
	timer_3_cmp_12.stop();
	taco::util::TimeResults res_3_cmp_12 = timer_3_cmp_12.getResult();
	cout << " | 3_cmp_12 ";
	cout << " | "<< res_3_cmp_12 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 1, 2)
int transpose_coo_04312_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 1, 2)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	taco::util::Timer timer_0_cmp_04321;
	timer_0_cmp_04321.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_04321);
	timer_0_cmp_04321.stop();
	taco::util::TimeResults res_0_cmp_04321 = timer_0_cmp_04321.getResult();
	cout << " | 0_cmp_04321 ";
	cout << " | "<< res_0_cmp_04321 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	taco::util::Timer timer_1_cmp_4321;
	timer_1_cmp_4321.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4321);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4321);
	timer_1_cmp_4321.stop();
	taco::util::TimeResults res_1_cmp_4321 = timer_1_cmp_4321.getResult();
	cout << " | 1_cmp_4321 ";
	cout << " | "<< res_1_cmp_4321 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_2_cmp_321;
	timer_2_cmp_321.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_321);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_321);
	timer_2_cmp_321.stop();
	taco::util::TimeResults res_2_cmp_321 = timer_2_cmp_321.getResult();
	cout << " | 2_cmp_321 ";
	cout << " | "<< res_2_cmp_321 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_3_cmp_21;
	timer_3_cmp_21.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_21);
	timer_3_cmp_21.stop();
	taco::util::TimeResults res_3_cmp_21 = timer_3_cmp_21.getResult();
	cout << " | 3_cmp_21 ";
	cout << " | "<< res_3_cmp_21 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (0, 4, 3, 2, 1)
int transpose_coo_04321_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (0, 4, 3, 2, 1)
	// Fix and sort on [0]
	taco::util::Timer timer_20;
	timer_20.start();
	// Create buckets and quotient
	int *bucket_20 = (int *)malloc(c_size*sizeof(int));
	int *quotient_20 = (int *)malloc(c_size*sizeof(int));
	int current_20 = 0;
	bucket_20[0] = 0;
	quotient_20[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_20++;
			quotient_20[current_20] = i;
		}
		bucket_20[i] = current_20;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_20[i];
		B2_count[idx2]--;
	}
	free(bucket_20);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_20[perm[i]]] = C_coords_scratch[i];
		quotient_20[perm[i]] ++;
	}
	free(quotient_20);
	timer_20.stop();
	taco::util::TimeResults res_20 = timer_20.getResult();
	cout << " , (2, [0]) ";
	cout << " , "<< res_20 ;
	// Fix and sort on [0]
	taco::util::Timer timer_30;
	timer_30.start();
	// Create buckets and quotient
	int *bucket_30 = (int *)malloc(c_size*sizeof(int));
	int *quotient_30 = (int *)malloc(c_size*sizeof(int));
	int current_30 = 0;
	bucket_30[0] = 0;
	quotient_30[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_30++;
			quotient_30[current_30] = i;
		}
		bucket_30[i] = current_30;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_30[i];
		B3_count[idx3]--;
	}
	free(bucket_30);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_30[perm[i]]] = C_coords_scratch[i];
		quotient_30[perm[i]] ++;
	}
	free(quotient_30);
	timer_30.stop();
	taco::util::TimeResults res_30 = timer_30.getResult();
	cout << " , (3, [0]) ";
	cout << " , "<< res_30 ;
	// Fix and sort on [0]
	taco::util::Timer timer_40;
	timer_40.start();
	// Create buckets and quotient
	int *bucket_40 = (int *)malloc(c_size*sizeof(int));
	int *quotient_40 = (int *)malloc(c_size*sizeof(int));
	int current_40 = 0;
	bucket_40[0] = 0;
	quotient_40[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_40++;
			quotient_40[current_40] = i;
		}
		bucket_40[i] = current_40;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_40[i];
		B4_count[idx4]--;
	}
	free(bucket_40);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_40[perm[i]]] = C_coords_scratch[i];
		quotient_40[perm[i]] ++;
	}
	free(quotient_40);
	timer_40.stop();
	taco::util::TimeResults res_40 = timer_40.getResult();
	cout << " , (4, [0]) ";
	cout << " , "<< res_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 0, 2, 3, 4)
	taco::util::Timer timer_0_cmp_10234;
	timer_0_cmp_10234.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10234);
	timer_0_cmp_10234.stop();
	taco::util::TimeResults res_0_cmp_10234 = timer_0_cmp_10234.getResult();
	cout << " | 0_cmp_10234 ";
	cout << " | "<< res_0_cmp_10234 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_0234;
	timer_1_cmp_0234.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0234);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0234);
	timer_1_cmp_0234.stop();
	taco::util::TimeResults res_1_cmp_0234 = timer_1_cmp_0234.getResult();
	cout << " | 1_cmp_0234 ";
	cout << " | "<< res_1_cmp_0234 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_234;
	timer_2_cmp_234.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_234);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_234);
	timer_2_cmp_234.stop();
	taco::util::TimeResults res_2_cmp_234 = timer_2_cmp_234.getResult();
	cout << " | 2_cmp_234 ";
	cout << " | "<< res_2_cmp_234 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_34;
	timer_3_cmp_34.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_34);
	timer_3_cmp_34.stop();
	taco::util::TimeResults res_3_cmp_34 = timer_3_cmp_34.getResult();
	cout << " | 3_cmp_34 ";
	cout << " | "<< res_3_cmp_34 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 3, 4)
int transpose_coo_10234_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 0, 2, 4, 3)
	taco::util::Timer timer_0_cmp_10243;
	timer_0_cmp_10243.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10243);
	timer_0_cmp_10243.stop();
	taco::util::TimeResults res_0_cmp_10243 = timer_0_cmp_10243.getResult();
	cout << " | 0_cmp_10243 ";
	cout << " | "<< res_0_cmp_10243 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_0243;
	timer_1_cmp_0243.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0243);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0243);
	timer_1_cmp_0243.stop();
	taco::util::TimeResults res_1_cmp_0243 = timer_1_cmp_0243.getResult();
	cout << " | 1_cmp_0243 ";
	cout << " | "<< res_1_cmp_0243 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_243;
	timer_2_cmp_243.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_243);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_243);
	timer_2_cmp_243.stop();
	taco::util::TimeResults res_2_cmp_243 = timer_2_cmp_243.getResult();
	cout << " | 2_cmp_243 ";
	cout << " | "<< res_2_cmp_243 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_43;
	timer_3_cmp_43.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_43);
	timer_3_cmp_43.stop();
	taco::util::TimeResults res_3_cmp_43 = timer_3_cmp_43.getResult();
	cout << " | 3_cmp_43 ";
	cout << " | "<< res_3_cmp_43 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0, 2]
	taco::util::Timer timer_4102;
	timer_4102.start();
	// Create buckets and quotient
	int *bucket_4102 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4102 = (int *)malloc(c_size*sizeof(int));
	int current_4102 = 0;
	bucket_4102[0] = 0;
	quotient_4102[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		bucket_4102[i] = current_4102;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4102[i];
		B4_count[idx4]--;
	}
	free(bucket_4102);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4102[perm[i]]] = C_coords_scratch[i];
		quotient_4102[perm[i]] ++;
	}
	free(quotient_4102);
	timer_4102.stop();
	taco::util::TimeResults res_4102 = timer_4102.getResult();
	cout << " , (4, [1, 0, 2]) ";
	cout << " , "<< res_4102 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 2, 4, 3)
int transpose_coo_10243_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 2, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0, 2]
	taco::util::Timer timer_4102;
	timer_4102.start();
	// Create buckets and quotient
	int *bucket_4102 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4102 = (int *)malloc(c_size*sizeof(int));
	int current_4102 = 0;
	bucket_4102[0] = 0;
	quotient_4102[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4102++;
			quotient_4102[current_4102] = i;
		}
		bucket_4102[i] = current_4102;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4102[i];
		B4_count[idx4]--;
	}
	free(bucket_4102);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4102[perm[i]]] = C_coords_scratch[i];
		quotient_4102[perm[i]] ++;
	}
	free(quotient_4102);
	timer_4102.stop();
	taco::util::TimeResults res_4102 = timer_4102.getResult();
	cout << " , (4, [1, 0, 2]) ";
	cout << " , "<< res_4102 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 0, 3, 2, 4)
	taco::util::Timer timer_0_cmp_10324;
	timer_0_cmp_10324.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10324);
	timer_0_cmp_10324.stop();
	taco::util::TimeResults res_0_cmp_10324 = timer_0_cmp_10324.getResult();
	cout << " | 0_cmp_10324 ";
	cout << " | "<< res_0_cmp_10324 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_0324;
	timer_1_cmp_0324.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0324);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0324);
	timer_1_cmp_0324.stop();
	taco::util::TimeResults res_1_cmp_0324 = timer_1_cmp_0324.getResult();
	cout << " | 1_cmp_0324 ";
	cout << " | "<< res_1_cmp_0324 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_324;
	timer_2_cmp_324.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_324);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_324);
	timer_2_cmp_324.stop();
	taco::util::TimeResults res_2_cmp_324 = timer_2_cmp_324.getResult();
	cout << " | 2_cmp_324 ";
	cout << " | "<< res_2_cmp_324 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	taco::util::Timer timer_3_cmp_24;
	timer_3_cmp_24.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_24);
	timer_3_cmp_24.stop();
	taco::util::TimeResults res_3_cmp_24 = timer_3_cmp_24.getResult();
	cout << " | 3_cmp_24 ";
	cout << " | "<< res_3_cmp_24 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 2, 4)
int transpose_coo_10324_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 0, 3, 4, 2)
	taco::util::Timer timer_0_cmp_10342;
	timer_0_cmp_10342.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10342);
	timer_0_cmp_10342.stop();
	taco::util::TimeResults res_0_cmp_10342 = timer_0_cmp_10342.getResult();
	cout << " | 0_cmp_10342 ";
	cout << " | "<< res_0_cmp_10342 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_0342;
	timer_1_cmp_0342.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0342);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0342);
	timer_1_cmp_0342.stop();
	taco::util::TimeResults res_1_cmp_0342 = timer_1_cmp_0342.getResult();
	cout << " | 1_cmp_0342 ";
	cout << " | "<< res_1_cmp_0342 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_342;
	timer_2_cmp_342.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_342);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_342);
	timer_2_cmp_342.stop();
	taco::util::TimeResults res_2_cmp_342 = timer_2_cmp_342.getResult();
	cout << " | 2_cmp_342 ";
	cout << " | "<< res_2_cmp_342 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	taco::util::Timer timer_3_cmp_42;
	timer_3_cmp_42.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_42);
	timer_3_cmp_42.stop();
	taco::util::TimeResults res_3_cmp_42 = timer_3_cmp_42.getResult();
	cout << " | 3_cmp_42 ";
	cout << " | "<< res_3_cmp_42 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 3, 4, 2)
int transpose_coo_10342_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 3, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 0, 4, 2, 3)
	taco::util::Timer timer_0_cmp_10423;
	timer_0_cmp_10423.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10423);
	timer_0_cmp_10423.stop();
	taco::util::TimeResults res_0_cmp_10423 = timer_0_cmp_10423.getResult();
	cout << " | 0_cmp_10423 ";
	cout << " | "<< res_0_cmp_10423 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_0423;
	timer_1_cmp_0423.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0423);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0423);
	timer_1_cmp_0423.stop();
	taco::util::TimeResults res_1_cmp_0423 = timer_1_cmp_0423.getResult();
	cout << " | 1_cmp_0423 ";
	cout << " | "<< res_1_cmp_0423 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_423;
	timer_2_cmp_423.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_423);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_423);
	timer_2_cmp_423.stop();
	taco::util::TimeResults res_2_cmp_423 = timer_2_cmp_423.getResult();
	cout << " | 2_cmp_423 ";
	cout << " | "<< res_2_cmp_423 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	taco::util::Timer timer_3_cmp_23;
	timer_3_cmp_23.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_23);
	timer_3_cmp_23.stop();
	taco::util::TimeResults res_3_cmp_23 = timer_3_cmp_23.getResult();
	cout << " | 3_cmp_23 ";
	cout << " | "<< res_3_cmp_23 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 2, 3)
int transpose_coo_10423_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 0, 4, 3, 2)
	taco::util::Timer timer_0_cmp_10432;
	timer_0_cmp_10432.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_10432);
	timer_0_cmp_10432.stop();
	taco::util::TimeResults res_0_cmp_10432 = timer_0_cmp_10432.getResult();
	cout << " | 0_cmp_10432 ";
	cout << " | "<< res_0_cmp_10432 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_0432;
	timer_1_cmp_0432.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0432);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0432);
	timer_1_cmp_0432.stop();
	taco::util::TimeResults res_1_cmp_0432 = timer_1_cmp_0432.getResult();
	cout << " | 1_cmp_0432 ";
	cout << " | "<< res_1_cmp_0432 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_432;
	timer_2_cmp_432.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_432);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_432);
	timer_2_cmp_432.stop();
	taco::util::TimeResults res_2_cmp_432 = timer_2_cmp_432.getResult();
	cout << " | 2_cmp_432 ";
	cout << " | "<< res_2_cmp_432 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	taco::util::Timer timer_3_cmp_32;
	timer_3_cmp_32.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_32);
	timer_3_cmp_32.stop();
	taco::util::TimeResults res_3_cmp_32 = timer_3_cmp_32.getResult();
	cout << " | 3_cmp_32 ";
	cout << " | "<< res_3_cmp_32 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 0, 4, 3, 2)
int transpose_coo_10432_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 0, 4, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_310;
	timer_310.start();
	// Create buckets and quotient
	int *bucket_310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_310 = (int *)malloc(c_size*sizeof(int));
	int current_310 = 0;
	bucket_310[0] = 0;
	quotient_310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_310++;
			quotient_310[current_310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_310++;
			quotient_310[current_310] = i;
		}
		bucket_310[i] = current_310;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_310[i];
		B3_count[idx3]--;
	}
	free(bucket_310);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_310[perm[i]]] = C_coords_scratch[i];
		quotient_310[perm[i]] ++;
	}
	free(quotient_310);
	timer_310.stop();
	taco::util::TimeResults res_310 = timer_310.getResult();
	cout << " , (3, [1, 0]) ";
	cout << " , "<< res_310 ;
	// Fix and sort on [1, 0]
	taco::util::Timer timer_410;
	timer_410.start();
	// Create buckets and quotient
	int *bucket_410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_410 = (int *)malloc(c_size*sizeof(int));
	int current_410 = 0;
	bucket_410[0] = 0;
	quotient_410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_410++;
			quotient_410[current_410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_410++;
			quotient_410[current_410] = i;
		}
		bucket_410[i] = current_410;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_410[i];
		B4_count[idx4]--;
	}
	free(bucket_410);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_410[perm[i]]] = C_coords_scratch[i];
		quotient_410[perm[i]] ++;
	}
	free(quotient_410);
	timer_410.stop();
	taco::util::TimeResults res_410 = timer_410.getResult();
	cout << " , (4, [1, 0]) ";
	cout << " , "<< res_410 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 2, 0, 3, 4)
	taco::util::Timer timer_0_cmp_12034;
	timer_0_cmp_12034.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12034);
	timer_0_cmp_12034.stop();
	taco::util::TimeResults res_0_cmp_12034 = timer_0_cmp_12034.getResult();
	cout << " | 0_cmp_12034 ";
	cout << " | "<< res_0_cmp_12034 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_2034;
	timer_1_cmp_2034.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2034);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2034);
	timer_1_cmp_2034.stop();
	taco::util::TimeResults res_1_cmp_2034 = timer_1_cmp_2034.getResult();
	cout << " | 1_cmp_2034 ";
	cout << " | "<< res_1_cmp_2034 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_034;
	timer_2_cmp_034.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_034);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_034);
	timer_2_cmp_034.stop();
	taco::util::TimeResults res_2_cmp_034 = timer_2_cmp_034.getResult();
	cout << " | 2_cmp_034 ";
	cout << " | "<< res_2_cmp_034 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_34;
	timer_3_cmp_34.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_34);
	timer_3_cmp_34.stop();
	taco::util::TimeResults res_3_cmp_34 = timer_3_cmp_34.getResult();
	cout << " | 3_cmp_34 ";
	cout << " | "<< res_3_cmp_34 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 3, 4)
int transpose_coo_12034_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 2, 0, 4, 3)
	taco::util::Timer timer_0_cmp_12043;
	timer_0_cmp_12043.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12043);
	timer_0_cmp_12043.stop();
	taco::util::TimeResults res_0_cmp_12043 = timer_0_cmp_12043.getResult();
	cout << " | 0_cmp_12043 ";
	cout << " | "<< res_0_cmp_12043 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_2043;
	timer_1_cmp_2043.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2043);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2043);
	timer_1_cmp_2043.stop();
	taco::util::TimeResults res_1_cmp_2043 = timer_1_cmp_2043.getResult();
	cout << " | 1_cmp_2043 ";
	cout << " | "<< res_1_cmp_2043 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_043;
	timer_2_cmp_043.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_043);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_043);
	timer_2_cmp_043.stop();
	taco::util::TimeResults res_2_cmp_043 = timer_2_cmp_043.getResult();
	cout << " | 2_cmp_043 ";
	cout << " | "<< res_2_cmp_043 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_43;
	timer_3_cmp_43.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_43);
	timer_3_cmp_43.stop();
	taco::util::TimeResults res_3_cmp_43 = timer_3_cmp_43.getResult();
	cout << " | 3_cmp_43 ";
	cout << " | "<< res_3_cmp_43 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 2, 0]
	taco::util::Timer timer_4120;
	timer_4120.start();
	// Create buckets and quotient
	int *bucket_4120 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4120 = (int *)malloc(c_size*sizeof(int));
	int current_4120 = 0;
	bucket_4120[0] = 0;
	quotient_4120[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		bucket_4120[i] = current_4120;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4120[i];
		B4_count[idx4]--;
	}
	free(bucket_4120);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4120[perm[i]]] = C_coords_scratch[i];
		quotient_4120[perm[i]] ++;
	}
	free(quotient_4120);
	timer_4120.stop();
	taco::util::TimeResults res_4120 = timer_4120.getResult();
	cout << " , (4, [1, 2, 0]) ";
	cout << " , "<< res_4120 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 0, 4, 3)
int transpose_coo_12043_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 0, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 2, 0]
	taco::util::Timer timer_4120;
	timer_4120.start();
	// Create buckets and quotient
	int *bucket_4120 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4120 = (int *)malloc(c_size*sizeof(int));
	int current_4120 = 0;
	bucket_4120[0] = 0;
	quotient_4120[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4120++;
			quotient_4120[current_4120] = i;
		}
		bucket_4120[i] = current_4120;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4120[i];
		B4_count[idx4]--;
	}
	free(bucket_4120);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4120[perm[i]]] = C_coords_scratch[i];
		quotient_4120[perm[i]] ++;
	}
	free(quotient_4120);
	timer_4120.stop();
	taco::util::TimeResults res_4120 = timer_4120.getResult();
	cout << " , (4, [1, 2, 0]) ";
	cout << " , "<< res_4120 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 2, 3, 0, 4)
	taco::util::Timer timer_0_cmp_12304;
	timer_0_cmp_12304.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12304);
	timer_0_cmp_12304.stop();
	taco::util::TimeResults res_0_cmp_12304 = timer_0_cmp_12304.getResult();
	cout << " | 0_cmp_12304 ";
	cout << " | "<< res_0_cmp_12304 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_2304;
	timer_1_cmp_2304.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2304);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2304);
	timer_1_cmp_2304.stop();
	taco::util::TimeResults res_1_cmp_2304 = timer_1_cmp_2304.getResult();
	cout << " | 1_cmp_2304 ";
	cout << " | "<< res_1_cmp_2304 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_304;
	timer_2_cmp_304.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_304);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_304);
	timer_2_cmp_304.stop();
	taco::util::TimeResults res_2_cmp_304 = timer_2_cmp_304.getResult();
	cout << " | 2_cmp_304 ";
	cout << " | "<< res_2_cmp_304 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_04;
	timer_3_cmp_04.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_04);
	timer_3_cmp_04.stop();
	taco::util::TimeResults res_3_cmp_04 = timer_3_cmp_04.getResult();
	cout << " | 3_cmp_04 ";
	cout << " | "<< res_3_cmp_04 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 0, 4)
int transpose_coo_12304_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 2, 3, 4, 0)
	taco::util::Timer timer_0_cmp_12340;
	timer_0_cmp_12340.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12340);
	timer_0_cmp_12340.stop();
	taco::util::TimeResults res_0_cmp_12340 = timer_0_cmp_12340.getResult();
	cout << " | 0_cmp_12340 ";
	cout << " | "<< res_0_cmp_12340 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_2340;
	timer_1_cmp_2340.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2340);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2340);
	timer_1_cmp_2340.stop();
	taco::util::TimeResults res_1_cmp_2340 = timer_1_cmp_2340.getResult();
	cout << " | 1_cmp_2340 ";
	cout << " | "<< res_1_cmp_2340 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_340;
	timer_2_cmp_340.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_340);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_340);
	timer_2_cmp_340.stop();
	taco::util::TimeResults res_2_cmp_340 = timer_2_cmp_340.getResult();
	cout << " | 2_cmp_340 ";
	cout << " | "<< res_2_cmp_340 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_40;
	timer_3_cmp_40.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_40);
	timer_3_cmp_40.stop();
	taco::util::TimeResults res_3_cmp_40 = timer_3_cmp_40.getResult();
	cout << " | 3_cmp_40 ";
	cout << " | "<< res_3_cmp_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 3, 4, 0)
int transpose_coo_12340_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 3, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 2, 4, 0, 3)
	taco::util::Timer timer_0_cmp_12403;
	timer_0_cmp_12403.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12403);
	timer_0_cmp_12403.stop();
	taco::util::TimeResults res_0_cmp_12403 = timer_0_cmp_12403.getResult();
	cout << " | 0_cmp_12403 ";
	cout << " | "<< res_0_cmp_12403 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_2403;
	timer_1_cmp_2403.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2403);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2403);
	timer_1_cmp_2403.stop();
	taco::util::TimeResults res_1_cmp_2403 = timer_1_cmp_2403.getResult();
	cout << " | 1_cmp_2403 ";
	cout << " | "<< res_1_cmp_2403 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_403;
	timer_2_cmp_403.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_403);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_403);
	timer_2_cmp_403.stop();
	taco::util::TimeResults res_2_cmp_403 = timer_2_cmp_403.getResult();
	cout << " | 2_cmp_403 ";
	cout << " | "<< res_2_cmp_403 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_03;
	timer_3_cmp_03.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_03);
	timer_3_cmp_03.stop();
	taco::util::TimeResults res_3_cmp_03 = timer_3_cmp_03.getResult();
	cout << " | 3_cmp_03 ";
	cout << " | "<< res_3_cmp_03 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 0, 3)
int transpose_coo_12403_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 2, 4, 3, 0)
	taco::util::Timer timer_0_cmp_12430;
	timer_0_cmp_12430.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_12430);
	timer_0_cmp_12430.stop();
	taco::util::TimeResults res_0_cmp_12430 = timer_0_cmp_12430.getResult();
	cout << " | 0_cmp_12430 ";
	cout << " | "<< res_0_cmp_12430 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_2430;
	timer_1_cmp_2430.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2430);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2430);
	timer_1_cmp_2430.stop();
	taco::util::TimeResults res_1_cmp_2430 = timer_1_cmp_2430.getResult();
	cout << " | 1_cmp_2430 ";
	cout << " | "<< res_1_cmp_2430 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_430;
	timer_2_cmp_430.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_430);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_430);
	timer_2_cmp_430.stop();
	taco::util::TimeResults res_2_cmp_430 = timer_2_cmp_430.getResult();
	cout << " | 2_cmp_430 ";
	cout << " | "<< res_2_cmp_430 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_30;
	timer_3_cmp_30.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_30);
	timer_3_cmp_30.stop();
	taco::util::TimeResults res_3_cmp_30 = timer_3_cmp_30.getResult();
	cout << " | 3_cmp_30 ";
	cout << " | "<< res_3_cmp_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 2, 4, 3, 0)
int transpose_coo_12430_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 2, 4, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 3, 0, 2, 4)
	taco::util::Timer timer_0_cmp_13024;
	timer_0_cmp_13024.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13024);
	timer_0_cmp_13024.stop();
	taco::util::TimeResults res_0_cmp_13024 = timer_0_cmp_13024.getResult();
	cout << " | 0_cmp_13024 ";
	cout << " | "<< res_0_cmp_13024 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_3024;
	timer_1_cmp_3024.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3024);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3024);
	timer_1_cmp_3024.stop();
	taco::util::TimeResults res_1_cmp_3024 = timer_1_cmp_3024.getResult();
	cout << " | 1_cmp_3024 ";
	cout << " | "<< res_1_cmp_3024 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_024;
	timer_2_cmp_024.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_024);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_024);
	timer_2_cmp_024.stop();
	taco::util::TimeResults res_2_cmp_024 = timer_2_cmp_024.getResult();
	cout << " | 2_cmp_024 ";
	cout << " | "<< res_2_cmp_024 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_24;
	timer_3_cmp_24.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_24);
	timer_3_cmp_24.stop();
	taco::util::TimeResults res_3_cmp_24 = timer_3_cmp_24.getResult();
	cout << " | 3_cmp_24 ";
	cout << " | "<< res_3_cmp_24 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 2, 4)
int transpose_coo_13024_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 3, 0, 4, 2)
	taco::util::Timer timer_0_cmp_13042;
	timer_0_cmp_13042.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13042);
	timer_0_cmp_13042.stop();
	taco::util::TimeResults res_0_cmp_13042 = timer_0_cmp_13042.getResult();
	cout << " | 0_cmp_13042 ";
	cout << " | "<< res_0_cmp_13042 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_3042;
	timer_1_cmp_3042.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3042);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3042);
	timer_1_cmp_3042.stop();
	taco::util::TimeResults res_1_cmp_3042 = timer_1_cmp_3042.getResult();
	cout << " | 1_cmp_3042 ";
	cout << " | "<< res_1_cmp_3042 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_042;
	timer_2_cmp_042.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_042);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_042);
	timer_2_cmp_042.stop();
	taco::util::TimeResults res_2_cmp_042 = timer_2_cmp_042.getResult();
	cout << " | 2_cmp_042 ";
	cout << " | "<< res_2_cmp_042 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_42;
	timer_3_cmp_42.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_42);
	timer_3_cmp_42.stop();
	taco::util::TimeResults res_3_cmp_42 = timer_3_cmp_42.getResult();
	cout << " | 3_cmp_42 ";
	cout << " | "<< res_3_cmp_42 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 3, 0]
	taco::util::Timer timer_4130;
	timer_4130.start();
	// Create buckets and quotient
	int *bucket_4130 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4130 = (int *)malloc(c_size*sizeof(int));
	int current_4130 = 0;
	bucket_4130[0] = 0;
	quotient_4130[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		bucket_4130[i] = current_4130;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4130[i];
		B4_count[idx4]--;
	}
	free(bucket_4130);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4130[perm[i]]] = C_coords_scratch[i];
		quotient_4130[perm[i]] ++;
	}
	free(quotient_4130);
	timer_4130.stop();
	taco::util::TimeResults res_4130 = timer_4130.getResult();
	cout << " , (4, [1, 3, 0]) ";
	cout << " , "<< res_4130 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 0, 4, 2)
int transpose_coo_13042_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 0, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 3, 0]
	taco::util::Timer timer_4130;
	timer_4130.start();
	// Create buckets and quotient
	int *bucket_4130 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4130 = (int *)malloc(c_size*sizeof(int));
	int current_4130 = 0;
	bucket_4130[0] = 0;
	quotient_4130[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4130++;
			quotient_4130[current_4130] = i;
		}
		bucket_4130[i] = current_4130;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4130[i];
		B4_count[idx4]--;
	}
	free(bucket_4130);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4130[perm[i]]] = C_coords_scratch[i];
		quotient_4130[perm[i]] ++;
	}
	free(quotient_4130);
	timer_4130.stop();
	taco::util::TimeResults res_4130 = timer_4130.getResult();
	cout << " , (4, [1, 3, 0]) ";
	cout << " , "<< res_4130 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 3, 2, 0, 4)
	taco::util::Timer timer_0_cmp_13204;
	timer_0_cmp_13204.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13204);
	timer_0_cmp_13204.stop();
	taco::util::TimeResults res_0_cmp_13204 = timer_0_cmp_13204.getResult();
	cout << " | 0_cmp_13204 ";
	cout << " | "<< res_0_cmp_13204 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_3204;
	timer_1_cmp_3204.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3204);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3204);
	timer_1_cmp_3204.stop();
	taco::util::TimeResults res_1_cmp_3204 = timer_1_cmp_3204.getResult();
	cout << " | 1_cmp_3204 ";
	cout << " | "<< res_1_cmp_3204 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_204;
	timer_2_cmp_204.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_204);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_204);
	timer_2_cmp_204.stop();
	taco::util::TimeResults res_2_cmp_204 = timer_2_cmp_204.getResult();
	cout << " | 2_cmp_204 ";
	cout << " | "<< res_2_cmp_204 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_04;
	timer_3_cmp_04.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_04);
	timer_3_cmp_04.stop();
	taco::util::TimeResults res_3_cmp_04 = timer_3_cmp_04.getResult();
	cout << " | 3_cmp_04 ";
	cout << " | "<< res_3_cmp_04 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 0, 4)
int transpose_coo_13204_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 3, 2, 4, 0)
	taco::util::Timer timer_0_cmp_13240;
	timer_0_cmp_13240.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13240);
	timer_0_cmp_13240.stop();
	taco::util::TimeResults res_0_cmp_13240 = timer_0_cmp_13240.getResult();
	cout << " | 0_cmp_13240 ";
	cout << " | "<< res_0_cmp_13240 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_3240;
	timer_1_cmp_3240.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3240);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3240);
	timer_1_cmp_3240.stop();
	taco::util::TimeResults res_1_cmp_3240 = timer_1_cmp_3240.getResult();
	cout << " | 1_cmp_3240 ";
	cout << " | "<< res_1_cmp_3240 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_240;
	timer_2_cmp_240.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_240);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_240);
	timer_2_cmp_240.stop();
	taco::util::TimeResults res_2_cmp_240 = timer_2_cmp_240.getResult();
	cout << " | 2_cmp_240 ";
	cout << " | "<< res_2_cmp_240 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_40;
	timer_3_cmp_40.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_40);
	timer_3_cmp_40.stop();
	taco::util::TimeResults res_3_cmp_40 = timer_3_cmp_40.getResult();
	cout << " | 3_cmp_40 ";
	cout << " | "<< res_3_cmp_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 2, 4, 0)
int transpose_coo_13240_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 2, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 3, 4, 0, 2)
	taco::util::Timer timer_0_cmp_13402;
	timer_0_cmp_13402.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13402);
	timer_0_cmp_13402.stop();
	taco::util::TimeResults res_0_cmp_13402 = timer_0_cmp_13402.getResult();
	cout << " | 0_cmp_13402 ";
	cout << " | "<< res_0_cmp_13402 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_3402;
	timer_1_cmp_3402.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3402);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3402);
	timer_1_cmp_3402.stop();
	taco::util::TimeResults res_1_cmp_3402 = timer_1_cmp_3402.getResult();
	cout << " | 1_cmp_3402 ";
	cout << " | "<< res_1_cmp_3402 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_402;
	timer_2_cmp_402.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_402);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_402);
	timer_2_cmp_402.stop();
	taco::util::TimeResults res_2_cmp_402 = timer_2_cmp_402.getResult();
	cout << " | 2_cmp_402 ";
	cout << " | "<< res_2_cmp_402 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_02;
	timer_3_cmp_02.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_02);
	timer_3_cmp_02.stop();
	taco::util::TimeResults res_3_cmp_02 = timer_3_cmp_02.getResult();
	cout << " | 3_cmp_02 ";
	cout << " | "<< res_3_cmp_02 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 0, 2)
int transpose_coo_13402_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 3, 4, 2, 0)
	taco::util::Timer timer_0_cmp_13420;
	timer_0_cmp_13420.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_13420);
	timer_0_cmp_13420.stop();
	taco::util::TimeResults res_0_cmp_13420 = timer_0_cmp_13420.getResult();
	cout << " | 0_cmp_13420 ";
	cout << " | "<< res_0_cmp_13420 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_3420;
	timer_1_cmp_3420.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3420);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3420);
	timer_1_cmp_3420.stop();
	taco::util::TimeResults res_1_cmp_3420 = timer_1_cmp_3420.getResult();
	cout << " | 1_cmp_3420 ";
	cout << " | "<< res_1_cmp_3420 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_420;
	timer_2_cmp_420.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_420);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_420);
	timer_2_cmp_420.stop();
	taco::util::TimeResults res_2_cmp_420 = timer_2_cmp_420.getResult();
	cout << " | 2_cmp_420 ";
	cout << " | "<< res_2_cmp_420 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_20;
	timer_3_cmp_20.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_20);
	timer_3_cmp_20.stop();
	taco::util::TimeResults res_3_cmp_20 = timer_3_cmp_20.getResult();
	cout << " | 3_cmp_20 ";
	cout << " | "<< res_3_cmp_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 3, 4, 2, 0)
int transpose_coo_13420_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 3, 4, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 4, 0, 2, 3)
	taco::util::Timer timer_0_cmp_14023;
	timer_0_cmp_14023.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14023);
	timer_0_cmp_14023.stop();
	taco::util::TimeResults res_0_cmp_14023 = timer_0_cmp_14023.getResult();
	cout << " | 0_cmp_14023 ";
	cout << " | "<< res_0_cmp_14023 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_4023;
	timer_1_cmp_4023.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4023);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4023);
	timer_1_cmp_4023.stop();
	taco::util::TimeResults res_1_cmp_4023 = timer_1_cmp_4023.getResult();
	cout << " | 1_cmp_4023 ";
	cout << " | "<< res_1_cmp_4023 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_023;
	timer_2_cmp_023.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_023);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_023);
	timer_2_cmp_023.stop();
	taco::util::TimeResults res_2_cmp_023 = timer_2_cmp_023.getResult();
	cout << " | 2_cmp_023 ";
	cout << " | "<< res_2_cmp_023 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_23;
	timer_3_cmp_23.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_23);
	timer_3_cmp_23.stop();
	taco::util::TimeResults res_3_cmp_23 = timer_3_cmp_23.getResult();
	cout << " | 3_cmp_23 ";
	cout << " | "<< res_3_cmp_23 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 2, 3)
int transpose_coo_14023_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 4, 0, 3, 2)
	taco::util::Timer timer_0_cmp_14032;
	timer_0_cmp_14032.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14032);
	timer_0_cmp_14032.stop();
	taco::util::TimeResults res_0_cmp_14032 = timer_0_cmp_14032.getResult();
	cout << " | 0_cmp_14032 ";
	cout << " | "<< res_0_cmp_14032 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_4032;
	timer_1_cmp_4032.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4032);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4032);
	timer_1_cmp_4032.stop();
	taco::util::TimeResults res_1_cmp_4032 = timer_1_cmp_4032.getResult();
	cout << " | 1_cmp_4032 ";
	cout << " | "<< res_1_cmp_4032 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_032;
	timer_2_cmp_032.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_032);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_032);
	timer_2_cmp_032.stop();
	taco::util::TimeResults res_2_cmp_032 = timer_2_cmp_032.getResult();
	cout << " | 2_cmp_032 ";
	cout << " | "<< res_2_cmp_032 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_32;
	timer_3_cmp_32.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_32);
	timer_3_cmp_32.stop();
	taco::util::TimeResults res_3_cmp_32 = timer_3_cmp_32.getResult();
	cout << " | 3_cmp_32 ";
	cout << " | "<< res_3_cmp_32 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 4, 0]
	taco::util::Timer timer_3140;
	timer_3140.start();
	// Create buckets and quotient
	int *bucket_3140 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3140 = (int *)malloc(c_size*sizeof(int));
	int current_3140 = 0;
	bucket_3140[0] = 0;
	quotient_3140[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		bucket_3140[i] = current_3140;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3140[i];
		B3_count[idx3]--;
	}
	free(bucket_3140);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3140[perm[i]]] = C_coords_scratch[i];
		quotient_3140[perm[i]] ++;
	}
	free(quotient_3140);
	timer_3140.stop();
	taco::util::TimeResults res_3140 = timer_3140.getResult();
	cout << " , (3, [1, 4, 0]) ";
	cout << " , "<< res_3140 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 0, 3, 2)
int transpose_coo_14032_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 0, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Fix and sort on [1, 4, 0]
	taco::util::Timer timer_3140;
	timer_3140.start();
	// Create buckets and quotient
	int *bucket_3140 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3140 = (int *)malloc(c_size*sizeof(int));
	int current_3140 = 0;
	bucket_3140[0] = 0;
	quotient_3140[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3140++;
			quotient_3140[current_3140] = i;
		}
		bucket_3140[i] = current_3140;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3140[i];
		B3_count[idx3]--;
	}
	free(bucket_3140);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3140[perm[i]]] = C_coords_scratch[i];
		quotient_3140[perm[i]] ++;
	}
	free(quotient_3140);
	timer_3140.stop();
	taco::util::TimeResults res_3140 = timer_3140.getResult();
	cout << " , (3, [1, 4, 0]) ";
	cout << " , "<< res_3140 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 4, 2, 0, 3)
	taco::util::Timer timer_0_cmp_14203;
	timer_0_cmp_14203.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14203);
	timer_0_cmp_14203.stop();
	taco::util::TimeResults res_0_cmp_14203 = timer_0_cmp_14203.getResult();
	cout << " | 0_cmp_14203 ";
	cout << " | "<< res_0_cmp_14203 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_4203;
	timer_1_cmp_4203.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4203);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4203);
	timer_1_cmp_4203.stop();
	taco::util::TimeResults res_1_cmp_4203 = timer_1_cmp_4203.getResult();
	cout << " | 1_cmp_4203 ";
	cout << " | "<< res_1_cmp_4203 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_203;
	timer_2_cmp_203.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_203);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_203);
	timer_2_cmp_203.stop();
	taco::util::TimeResults res_2_cmp_203 = timer_2_cmp_203.getResult();
	cout << " | 2_cmp_203 ";
	cout << " | "<< res_2_cmp_203 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_03;
	timer_3_cmp_03.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_03);
	timer_3_cmp_03.stop();
	taco::util::TimeResults res_3_cmp_03 = timer_3_cmp_03.getResult();
	cout << " | 3_cmp_03 ";
	cout << " | "<< res_3_cmp_03 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 0, 3)
int transpose_coo_14203_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 4, 2, 3, 0)
	taco::util::Timer timer_0_cmp_14230;
	timer_0_cmp_14230.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14230);
	timer_0_cmp_14230.stop();
	taco::util::TimeResults res_0_cmp_14230 = timer_0_cmp_14230.getResult();
	cout << " | 0_cmp_14230 ";
	cout << " | "<< res_0_cmp_14230 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_4230;
	timer_1_cmp_4230.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4230);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4230);
	timer_1_cmp_4230.stop();
	taco::util::TimeResults res_1_cmp_4230 = timer_1_cmp_4230.getResult();
	cout << " | 1_cmp_4230 ";
	cout << " | "<< res_1_cmp_4230 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_230;
	timer_2_cmp_230.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_230);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_230);
	timer_2_cmp_230.stop();
	taco::util::TimeResults res_2_cmp_230 = timer_2_cmp_230.getResult();
	cout << " | 2_cmp_230 ";
	cout << " | "<< res_2_cmp_230 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_30;
	timer_3_cmp_30.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_30);
	timer_3_cmp_30.stop();
	taco::util::TimeResults res_3_cmp_30 = timer_3_cmp_30.getResult();
	cout << " | 3_cmp_30 ";
	cout << " | "<< res_3_cmp_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 2, 3, 0)
int transpose_coo_14230_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 2, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 4, 3, 0, 2)
	taco::util::Timer timer_0_cmp_14302;
	timer_0_cmp_14302.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14302);
	timer_0_cmp_14302.stop();
	taco::util::TimeResults res_0_cmp_14302 = timer_0_cmp_14302.getResult();
	cout << " | 0_cmp_14302 ";
	cout << " | "<< res_0_cmp_14302 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_4302;
	timer_1_cmp_4302.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4302);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4302);
	timer_1_cmp_4302.stop();
	taco::util::TimeResults res_1_cmp_4302 = timer_1_cmp_4302.getResult();
	cout << " | 1_cmp_4302 ";
	cout << " | "<< res_1_cmp_4302 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_302;
	timer_2_cmp_302.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_302);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_302);
	timer_2_cmp_302.stop();
	taco::util::TimeResults res_2_cmp_302 = timer_2_cmp_302.getResult();
	cout << " | 2_cmp_302 ";
	cout << " | "<< res_2_cmp_302 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_02;
	timer_3_cmp_02.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_02);
	timer_3_cmp_02.stop();
	taco::util::TimeResults res_3_cmp_02 = timer_3_cmp_02.getResult();
	cout << " | 3_cmp_02 ";
	cout << " | "<< res_3_cmp_02 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 0, 2)
int transpose_coo_14302_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (1, 4, 3, 2, 0)
	taco::util::Timer timer_0_cmp_14320;
	timer_0_cmp_14320.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_14320);
	timer_0_cmp_14320.stop();
	taco::util::TimeResults res_0_cmp_14320 = timer_0_cmp_14320.getResult();
	cout << " | 0_cmp_14320 ";
	cout << " | "<< res_0_cmp_14320 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_1_cmp_4320;
	timer_1_cmp_4320.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4320);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4320);
	timer_1_cmp_4320.stop();
	taco::util::TimeResults res_1_cmp_4320 = timer_1_cmp_4320.getResult();
	cout << " | 1_cmp_4320 ";
	cout << " | "<< res_1_cmp_4320 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2_cmp_320;
	timer_2_cmp_320.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_320);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_320);
	timer_2_cmp_320.stop();
	taco::util::TimeResults res_2_cmp_320 = timer_2_cmp_320.getResult();
	cout << " | 2_cmp_320 ";
	cout << " | "<< res_2_cmp_320 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3_cmp_20;
	timer_3_cmp_20.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_20);
	timer_3_cmp_20.stop();
	taco::util::TimeResults res_3_cmp_20 = timer_3_cmp_20.getResult();
	cout << " | 3_cmp_20 ";
	cout << " | "<< res_3_cmp_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (1, 4, 3, 2, 0)
int transpose_coo_14320_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (1, 4, 3, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 0, 1, 3, 4)
	taco::util::Timer timer_0_cmp_20134;
	timer_0_cmp_20134.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20134);
	timer_0_cmp_20134.stop();
	taco::util::TimeResults res_0_cmp_20134 = timer_0_cmp_20134.getResult();
	cout << " | 0_cmp_20134 ";
	cout << " | "<< res_0_cmp_20134 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_0134;
	timer_1_cmp_0134.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0134);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0134);
	timer_1_cmp_0134.stop();
	taco::util::TimeResults res_1_cmp_0134 = timer_1_cmp_0134.getResult();
	cout << " | 1_cmp_0134 ";
	cout << " | "<< res_1_cmp_0134 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_134;
	timer_2_cmp_134.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_134);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_134);
	timer_2_cmp_134.stop();
	taco::util::TimeResults res_2_cmp_134 = timer_2_cmp_134.getResult();
	cout << " | 2_cmp_134 ";
	cout << " | "<< res_2_cmp_134 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_34;
	timer_3_cmp_34.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_34);
	timer_3_cmp_34.stop();
	taco::util::TimeResults res_3_cmp_34 = timer_3_cmp_34.getResult();
	cout << " | 3_cmp_34 ";
	cout << " | "<< res_3_cmp_34 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 3, 4)
int transpose_coo_20134_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 0, 1, 4, 3)
	taco::util::Timer timer_0_cmp_20143;
	timer_0_cmp_20143.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20143);
	timer_0_cmp_20143.stop();
	taco::util::TimeResults res_0_cmp_20143 = timer_0_cmp_20143.getResult();
	cout << " | 0_cmp_20143 ";
	cout << " | "<< res_0_cmp_20143 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_0143;
	timer_1_cmp_0143.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0143);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0143);
	timer_1_cmp_0143.stop();
	taco::util::TimeResults res_1_cmp_0143 = timer_1_cmp_0143.getResult();
	cout << " | 1_cmp_0143 ";
	cout << " | "<< res_1_cmp_0143 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_143;
	timer_2_cmp_143.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_143);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_143);
	timer_2_cmp_143.stop();
	taco::util::TimeResults res_2_cmp_143 = timer_2_cmp_143.getResult();
	cout << " | 2_cmp_143 ";
	cout << " | "<< res_2_cmp_143 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_43;
	timer_3_cmp_43.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_43);
	timer_3_cmp_43.stop();
	taco::util::TimeResults res_3_cmp_43 = timer_3_cmp_43.getResult();
	cout << " | 3_cmp_43 ";
	cout << " | "<< res_3_cmp_43 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0, 1]
	taco::util::Timer timer_4201;
	timer_4201.start();
	// Create buckets and quotient
	int *bucket_4201 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4201 = (int *)malloc(c_size*sizeof(int));
	int current_4201 = 0;
	bucket_4201[0] = 0;
	quotient_4201[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		bucket_4201[i] = current_4201;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4201[i];
		B4_count[idx4]--;
	}
	free(bucket_4201);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4201[perm[i]]] = C_coords_scratch[i];
		quotient_4201[perm[i]] ++;
	}
	free(quotient_4201);
	timer_4201.stop();
	taco::util::TimeResults res_4201 = timer_4201.getResult();
	cout << " , (4, [2, 0, 1]) ";
	cout << " , "<< res_4201 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 1, 4, 3)
int transpose_coo_20143_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 1, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0, 1]
	taco::util::Timer timer_4201;
	timer_4201.start();
	// Create buckets and quotient
	int *bucket_4201 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4201 = (int *)malloc(c_size*sizeof(int));
	int current_4201 = 0;
	bucket_4201[0] = 0;
	quotient_4201[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4201++;
			quotient_4201[current_4201] = i;
		}
		bucket_4201[i] = current_4201;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4201[i];
		B4_count[idx4]--;
	}
	free(bucket_4201);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4201[perm[i]]] = C_coords_scratch[i];
		quotient_4201[perm[i]] ++;
	}
	free(quotient_4201);
	timer_4201.stop();
	taco::util::TimeResults res_4201 = timer_4201.getResult();
	cout << " , (4, [2, 0, 1]) ";
	cout << " , "<< res_4201 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 0, 3, 1, 4)
	taco::util::Timer timer_0_cmp_20314;
	timer_0_cmp_20314.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20314);
	timer_0_cmp_20314.stop();
	taco::util::TimeResults res_0_cmp_20314 = timer_0_cmp_20314.getResult();
	cout << " | 0_cmp_20314 ";
	cout << " | "<< res_0_cmp_20314 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_0314;
	timer_1_cmp_0314.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0314);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0314);
	timer_1_cmp_0314.stop();
	taco::util::TimeResults res_1_cmp_0314 = timer_1_cmp_0314.getResult();
	cout << " | 1_cmp_0314 ";
	cout << " | "<< res_1_cmp_0314 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_314;
	timer_2_cmp_314.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_314);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_314);
	timer_2_cmp_314.stop();
	taco::util::TimeResults res_2_cmp_314 = timer_2_cmp_314.getResult();
	cout << " | 2_cmp_314 ";
	cout << " | "<< res_2_cmp_314 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	taco::util::Timer timer_3_cmp_14;
	timer_3_cmp_14.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_14);
	timer_3_cmp_14.stop();
	taco::util::TimeResults res_3_cmp_14 = timer_3_cmp_14.getResult();
	cout << " | 3_cmp_14 ";
	cout << " | "<< res_3_cmp_14 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 1, 4)
int transpose_coo_20314_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 0, 3, 4, 1)
	taco::util::Timer timer_0_cmp_20341;
	timer_0_cmp_20341.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20341);
	timer_0_cmp_20341.stop();
	taco::util::TimeResults res_0_cmp_20341 = timer_0_cmp_20341.getResult();
	cout << " | 0_cmp_20341 ";
	cout << " | "<< res_0_cmp_20341 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_0341;
	timer_1_cmp_0341.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0341);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0341);
	timer_1_cmp_0341.stop();
	taco::util::TimeResults res_1_cmp_0341 = timer_1_cmp_0341.getResult();
	cout << " | 1_cmp_0341 ";
	cout << " | "<< res_1_cmp_0341 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_341;
	timer_2_cmp_341.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_341);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_341);
	timer_2_cmp_341.stop();
	taco::util::TimeResults res_2_cmp_341 = timer_2_cmp_341.getResult();
	cout << " | 2_cmp_341 ";
	cout << " | "<< res_2_cmp_341 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	taco::util::Timer timer_3_cmp_41;
	timer_3_cmp_41.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_41);
	timer_3_cmp_41.stop();
	taco::util::TimeResults res_3_cmp_41 = timer_3_cmp_41.getResult();
	cout << " | 3_cmp_41 ";
	cout << " | "<< res_3_cmp_41 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 3, 4, 1)
int transpose_coo_20341_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 3, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 0, 4, 1, 3)
	taco::util::Timer timer_0_cmp_20413;
	timer_0_cmp_20413.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20413);
	timer_0_cmp_20413.stop();
	taco::util::TimeResults res_0_cmp_20413 = timer_0_cmp_20413.getResult();
	cout << " | 0_cmp_20413 ";
	cout << " | "<< res_0_cmp_20413 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_0413;
	timer_1_cmp_0413.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0413);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0413);
	timer_1_cmp_0413.stop();
	taco::util::TimeResults res_1_cmp_0413 = timer_1_cmp_0413.getResult();
	cout << " | 1_cmp_0413 ";
	cout << " | "<< res_1_cmp_0413 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_413;
	timer_2_cmp_413.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_413);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_413);
	timer_2_cmp_413.stop();
	taco::util::TimeResults res_2_cmp_413 = timer_2_cmp_413.getResult();
	cout << " | 2_cmp_413 ";
	cout << " | "<< res_2_cmp_413 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	taco::util::Timer timer_3_cmp_13;
	timer_3_cmp_13.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_13);
	timer_3_cmp_13.stop();
	taco::util::TimeResults res_3_cmp_13 = timer_3_cmp_13.getResult();
	cout << " | 3_cmp_13 ";
	cout << " | "<< res_3_cmp_13 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 1, 3)
int transpose_coo_20413_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 0, 4, 3, 1)
	taco::util::Timer timer_0_cmp_20431;
	timer_0_cmp_20431.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_20431);
	timer_0_cmp_20431.stop();
	taco::util::TimeResults res_0_cmp_20431 = timer_0_cmp_20431.getResult();
	cout << " | 0_cmp_20431 ";
	cout << " | "<< res_0_cmp_20431 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_0431;
	timer_1_cmp_0431.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0431);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0431);
	timer_1_cmp_0431.stop();
	taco::util::TimeResults res_1_cmp_0431 = timer_1_cmp_0431.getResult();
	cout << " | 1_cmp_0431 ";
	cout << " | "<< res_1_cmp_0431 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_431;
	timer_2_cmp_431.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_431);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_431);
	timer_2_cmp_431.stop();
	taco::util::TimeResults res_2_cmp_431 = timer_2_cmp_431.getResult();
	cout << " | 2_cmp_431 ";
	cout << " | "<< res_2_cmp_431 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	taco::util::Timer timer_3_cmp_31;
	timer_3_cmp_31.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_31);
	timer_3_cmp_31.stop();
	taco::util::TimeResults res_3_cmp_31 = timer_3_cmp_31.getResult();
	cout << " | 3_cmp_31 ";
	cout << " | "<< res_3_cmp_31 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 0, 4, 3, 1)
int transpose_coo_20431_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 0, 4, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_320;
	timer_320.start();
	// Create buckets and quotient
	int *bucket_320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_320 = (int *)malloc(c_size*sizeof(int));
	int current_320 = 0;
	bucket_320[0] = 0;
	quotient_320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_320++;
			quotient_320[current_320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_320++;
			quotient_320[current_320] = i;
		}
		bucket_320[i] = current_320;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_320[i];
		B3_count[idx3]--;
	}
	free(bucket_320);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_320[perm[i]]] = C_coords_scratch[i];
		quotient_320[perm[i]] ++;
	}
	free(quotient_320);
	timer_320.stop();
	taco::util::TimeResults res_320 = timer_320.getResult();
	cout << " , (3, [2, 0]) ";
	cout << " , "<< res_320 ;
	// Fix and sort on [2, 0]
	taco::util::Timer timer_420;
	timer_420.start();
	// Create buckets and quotient
	int *bucket_420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_420 = (int *)malloc(c_size*sizeof(int));
	int current_420 = 0;
	bucket_420[0] = 0;
	quotient_420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_420++;
			quotient_420[current_420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_420++;
			quotient_420[current_420] = i;
		}
		bucket_420[i] = current_420;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_420[i];
		B4_count[idx4]--;
	}
	free(bucket_420);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_420[perm[i]]] = C_coords_scratch[i];
		quotient_420[perm[i]] ++;
	}
	free(quotient_420);
	timer_420.stop();
	taco::util::TimeResults res_420 = timer_420.getResult();
	cout << " , (4, [2, 0]) ";
	cout << " , "<< res_420 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 1, 0, 3, 4)
	taco::util::Timer timer_0_cmp_21034;
	timer_0_cmp_21034.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21034);
	timer_0_cmp_21034.stop();
	taco::util::TimeResults res_0_cmp_21034 = timer_0_cmp_21034.getResult();
	cout << " | 0_cmp_21034 ";
	cout << " | "<< res_0_cmp_21034 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_1034;
	timer_1_cmp_1034.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1034);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1034);
	timer_1_cmp_1034.stop();
	taco::util::TimeResults res_1_cmp_1034 = timer_1_cmp_1034.getResult();
	cout << " | 1_cmp_1034 ";
	cout << " | "<< res_1_cmp_1034 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_034;
	timer_2_cmp_034.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_034);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_034);
	timer_2_cmp_034.stop();
	taco::util::TimeResults res_2_cmp_034 = timer_2_cmp_034.getResult();
	cout << " | 2_cmp_034 ";
	cout << " | "<< res_2_cmp_034 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_34;
	timer_3_cmp_34.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_34);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_34);
	timer_3_cmp_34.stop();
	taco::util::TimeResults res_3_cmp_34 = timer_3_cmp_34.getResult();
	cout << " | 3_cmp_34 ";
	cout << " | "<< res_3_cmp_34 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 3, 4)
int transpose_coo_21034_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 3, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 1, 0, 4, 3)
	taco::util::Timer timer_0_cmp_21043;
	timer_0_cmp_21043.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21043);
	timer_0_cmp_21043.stop();
	taco::util::TimeResults res_0_cmp_21043 = timer_0_cmp_21043.getResult();
	cout << " | 0_cmp_21043 ";
	cout << " | "<< res_0_cmp_21043 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_1043;
	timer_1_cmp_1043.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1043);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1043);
	timer_1_cmp_1043.stop();
	taco::util::TimeResults res_1_cmp_1043 = timer_1_cmp_1043.getResult();
	cout << " | 1_cmp_1043 ";
	cout << " | "<< res_1_cmp_1043 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_043;
	timer_2_cmp_043.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_043);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_043);
	timer_2_cmp_043.stop();
	taco::util::TimeResults res_2_cmp_043 = timer_2_cmp_043.getResult();
	cout << " | 2_cmp_043 ";
	cout << " | "<< res_2_cmp_043 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_43;
	timer_3_cmp_43.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_43);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_43);
	timer_3_cmp_43.stop();
	taco::util::TimeResults res_3_cmp_43 = timer_3_cmp_43.getResult();
	cout << " | 3_cmp_43 ";
	cout << " | "<< res_3_cmp_43 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 1, 0]
	taco::util::Timer timer_4210;
	timer_4210.start();
	// Create buckets and quotient
	int *bucket_4210 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4210 = (int *)malloc(c_size*sizeof(int));
	int current_4210 = 0;
	bucket_4210[0] = 0;
	quotient_4210[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		bucket_4210[i] = current_4210;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4210[i];
		B4_count[idx4]--;
	}
	free(bucket_4210);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4210[perm[i]]] = C_coords_scratch[i];
		quotient_4210[perm[i]] ++;
	}
	free(quotient_4210);
	timer_4210.stop();
	taco::util::TimeResults res_4210 = timer_4210.getResult();
	cout << " , (4, [2, 1, 0]) ";
	cout << " , "<< res_4210 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 0, 4, 3)
int transpose_coo_21043_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 0, 4, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 1, 0]
	taco::util::Timer timer_4210;
	timer_4210.start();
	// Create buckets and quotient
	int *bucket_4210 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4210 = (int *)malloc(c_size*sizeof(int));
	int current_4210 = 0;
	bucket_4210[0] = 0;
	quotient_4210[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4210++;
			quotient_4210[current_4210] = i;
		}
		bucket_4210[i] = current_4210;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4210[i];
		B4_count[idx4]--;
	}
	free(bucket_4210);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4210[perm[i]]] = C_coords_scratch[i];
		quotient_4210[perm[i]] ++;
	}
	free(quotient_4210);
	timer_4210.stop();
	taco::util::TimeResults res_4210 = timer_4210.getResult();
	cout << " , (4, [2, 1, 0]) ";
	cout << " , "<< res_4210 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 1, 3, 0, 4)
	taco::util::Timer timer_0_cmp_21304;
	timer_0_cmp_21304.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21304);
	timer_0_cmp_21304.stop();
	taco::util::TimeResults res_0_cmp_21304 = timer_0_cmp_21304.getResult();
	cout << " | 0_cmp_21304 ";
	cout << " | "<< res_0_cmp_21304 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_1304;
	timer_1_cmp_1304.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1304);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1304);
	timer_1_cmp_1304.stop();
	taco::util::TimeResults res_1_cmp_1304 = timer_1_cmp_1304.getResult();
	cout << " | 1_cmp_1304 ";
	cout << " | "<< res_1_cmp_1304 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_304;
	timer_2_cmp_304.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_304);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_304);
	timer_2_cmp_304.stop();
	taco::util::TimeResults res_2_cmp_304 = timer_2_cmp_304.getResult();
	cout << " | 2_cmp_304 ";
	cout << " | "<< res_2_cmp_304 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_04;
	timer_3_cmp_04.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_04);
	timer_3_cmp_04.stop();
	taco::util::TimeResults res_3_cmp_04 = timer_3_cmp_04.getResult();
	cout << " | 3_cmp_04 ";
	cout << " | "<< res_3_cmp_04 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 0, 4)
int transpose_coo_21304_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 1, 3, 4, 0)
	taco::util::Timer timer_0_cmp_21340;
	timer_0_cmp_21340.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21340);
	timer_0_cmp_21340.stop();
	taco::util::TimeResults res_0_cmp_21340 = timer_0_cmp_21340.getResult();
	cout << " | 0_cmp_21340 ";
	cout << " | "<< res_0_cmp_21340 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_1340;
	timer_1_cmp_1340.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1340);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1340);
	timer_1_cmp_1340.stop();
	taco::util::TimeResults res_1_cmp_1340 = timer_1_cmp_1340.getResult();
	cout << " | 1_cmp_1340 ";
	cout << " | "<< res_1_cmp_1340 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_340;
	timer_2_cmp_340.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_340);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_340);
	timer_2_cmp_340.stop();
	taco::util::TimeResults res_2_cmp_340 = timer_2_cmp_340.getResult();
	cout << " | 2_cmp_340 ";
	cout << " | "<< res_2_cmp_340 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_40;
	timer_3_cmp_40.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_40);
	timer_3_cmp_40.stop();
	taco::util::TimeResults res_3_cmp_40 = timer_3_cmp_40.getResult();
	cout << " | 3_cmp_40 ";
	cout << " | "<< res_3_cmp_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 3, 4, 0)
int transpose_coo_21340_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 3, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 1, 4, 0, 3)
	taco::util::Timer timer_0_cmp_21403;
	timer_0_cmp_21403.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21403);
	timer_0_cmp_21403.stop();
	taco::util::TimeResults res_0_cmp_21403 = timer_0_cmp_21403.getResult();
	cout << " | 0_cmp_21403 ";
	cout << " | "<< res_0_cmp_21403 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_1403;
	timer_1_cmp_1403.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1403);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1403);
	timer_1_cmp_1403.stop();
	taco::util::TimeResults res_1_cmp_1403 = timer_1_cmp_1403.getResult();
	cout << " | 1_cmp_1403 ";
	cout << " | "<< res_1_cmp_1403 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_403;
	timer_2_cmp_403.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_403);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_403);
	timer_2_cmp_403.stop();
	taco::util::TimeResults res_2_cmp_403 = timer_2_cmp_403.getResult();
	cout << " | 2_cmp_403 ";
	cout << " | "<< res_2_cmp_403 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_03;
	timer_3_cmp_03.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_03);
	timer_3_cmp_03.stop();
	taco::util::TimeResults res_3_cmp_03 = timer_3_cmp_03.getResult();
	cout << " | 3_cmp_03 ";
	cout << " | "<< res_3_cmp_03 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 0, 3)
int transpose_coo_21403_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 1, 4, 3, 0)
	taco::util::Timer timer_0_cmp_21430;
	timer_0_cmp_21430.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_21430);
	timer_0_cmp_21430.stop();
	taco::util::TimeResults res_0_cmp_21430 = timer_0_cmp_21430.getResult();
	cout << " | 0_cmp_21430 ";
	cout << " | "<< res_0_cmp_21430 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_1430;
	timer_1_cmp_1430.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1430);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1430);
	timer_1_cmp_1430.stop();
	taco::util::TimeResults res_1_cmp_1430 = timer_1_cmp_1430.getResult();
	cout << " | 1_cmp_1430 ";
	cout << " | "<< res_1_cmp_1430 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_430;
	timer_2_cmp_430.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_430);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_430);
	timer_2_cmp_430.stop();
	taco::util::TimeResults res_2_cmp_430 = timer_2_cmp_430.getResult();
	cout << " | 2_cmp_430 ";
	cout << " | "<< res_2_cmp_430 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_30;
	timer_3_cmp_30.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_30);
	timer_3_cmp_30.stop();
	taco::util::TimeResults res_3_cmp_30 = timer_3_cmp_30.getResult();
	cout << " | 3_cmp_30 ";
	cout << " | "<< res_3_cmp_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 1, 4, 3, 0)
int transpose_coo_21430_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 1, 4, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 3, 0, 1, 4)
	taco::util::Timer timer_0_cmp_23014;
	timer_0_cmp_23014.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23014);
	timer_0_cmp_23014.stop();
	taco::util::TimeResults res_0_cmp_23014 = timer_0_cmp_23014.getResult();
	cout << " | 0_cmp_23014 ";
	cout << " | "<< res_0_cmp_23014 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_3014;
	timer_1_cmp_3014.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3014);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3014);
	timer_1_cmp_3014.stop();
	taco::util::TimeResults res_1_cmp_3014 = timer_1_cmp_3014.getResult();
	cout << " | 1_cmp_3014 ";
	cout << " | "<< res_1_cmp_3014 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_014;
	timer_2_cmp_014.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_014);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_014);
	timer_2_cmp_014.stop();
	taco::util::TimeResults res_2_cmp_014 = timer_2_cmp_014.getResult();
	cout << " | 2_cmp_014 ";
	cout << " | "<< res_2_cmp_014 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_14;
	timer_3_cmp_14.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_14);
	timer_3_cmp_14.stop();
	taco::util::TimeResults res_3_cmp_14 = timer_3_cmp_14.getResult();
	cout << " | 3_cmp_14 ";
	cout << " | "<< res_3_cmp_14 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 1, 4)
int transpose_coo_23014_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 3, 0, 4, 1)
	taco::util::Timer timer_0_cmp_23041;
	timer_0_cmp_23041.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23041);
	timer_0_cmp_23041.stop();
	taco::util::TimeResults res_0_cmp_23041 = timer_0_cmp_23041.getResult();
	cout << " | 0_cmp_23041 ";
	cout << " | "<< res_0_cmp_23041 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_3041;
	timer_1_cmp_3041.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3041);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3041);
	timer_1_cmp_3041.stop();
	taco::util::TimeResults res_1_cmp_3041 = timer_1_cmp_3041.getResult();
	cout << " | 1_cmp_3041 ";
	cout << " | "<< res_1_cmp_3041 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_041;
	timer_2_cmp_041.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_041);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_041);
	timer_2_cmp_041.stop();
	taco::util::TimeResults res_2_cmp_041 = timer_2_cmp_041.getResult();
	cout << " | 2_cmp_041 ";
	cout << " | "<< res_2_cmp_041 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_41;
	timer_3_cmp_41.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_41);
	timer_3_cmp_41.stop();
	taco::util::TimeResults res_3_cmp_41 = timer_3_cmp_41.getResult();
	cout << " | 3_cmp_41 ";
	cout << " | "<< res_3_cmp_41 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 3, 0]
	taco::util::Timer timer_4230;
	timer_4230.start();
	// Create buckets and quotient
	int *bucket_4230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4230 = (int *)malloc(c_size*sizeof(int));
	int current_4230 = 0;
	bucket_4230[0] = 0;
	quotient_4230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		bucket_4230[i] = current_4230;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4230[i];
		B4_count[idx4]--;
	}
	free(bucket_4230);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4230[perm[i]]] = C_coords_scratch[i];
		quotient_4230[perm[i]] ++;
	}
	free(quotient_4230);
	timer_4230.stop();
	taco::util::TimeResults res_4230 = timer_4230.getResult();
	cout << " , (4, [2, 3, 0]) ";
	cout << " , "<< res_4230 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 0, 4, 1)
int transpose_coo_23041_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 0, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 3, 0]
	taco::util::Timer timer_4230;
	timer_4230.start();
	// Create buckets and quotient
	int *bucket_4230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4230 = (int *)malloc(c_size*sizeof(int));
	int current_4230 = 0;
	bucket_4230[0] = 0;
	quotient_4230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4230++;
			quotient_4230[current_4230] = i;
		}
		bucket_4230[i] = current_4230;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4230[i];
		B4_count[idx4]--;
	}
	free(bucket_4230);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4230[perm[i]]] = C_coords_scratch[i];
		quotient_4230[perm[i]] ++;
	}
	free(quotient_4230);
	timer_4230.stop();
	taco::util::TimeResults res_4230 = timer_4230.getResult();
	cout << " , (4, [2, 3, 0]) ";
	cout << " , "<< res_4230 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 3, 1, 0, 4)
	taco::util::Timer timer_0_cmp_23104;
	timer_0_cmp_23104.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23104);
	timer_0_cmp_23104.stop();
	taco::util::TimeResults res_0_cmp_23104 = timer_0_cmp_23104.getResult();
	cout << " | 0_cmp_23104 ";
	cout << " | "<< res_0_cmp_23104 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_3104;
	timer_1_cmp_3104.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3104);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3104);
	timer_1_cmp_3104.stop();
	taco::util::TimeResults res_1_cmp_3104 = timer_1_cmp_3104.getResult();
	cout << " | 1_cmp_3104 ";
	cout << " | "<< res_1_cmp_3104 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_104;
	timer_2_cmp_104.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_104);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_104);
	timer_2_cmp_104.stop();
	taco::util::TimeResults res_2_cmp_104 = timer_2_cmp_104.getResult();
	cout << " | 2_cmp_104 ";
	cout << " | "<< res_2_cmp_104 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_04;
	timer_3_cmp_04.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_04);
	timer_3_cmp_04.stop();
	taco::util::TimeResults res_3_cmp_04 = timer_3_cmp_04.getResult();
	cout << " | 3_cmp_04 ";
	cout << " | "<< res_3_cmp_04 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 0, 4)
int transpose_coo_23104_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 3, 1, 4, 0)
	taco::util::Timer timer_0_cmp_23140;
	timer_0_cmp_23140.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23140);
	timer_0_cmp_23140.stop();
	taco::util::TimeResults res_0_cmp_23140 = timer_0_cmp_23140.getResult();
	cout << " | 0_cmp_23140 ";
	cout << " | "<< res_0_cmp_23140 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_3140;
	timer_1_cmp_3140.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3140);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3140);
	timer_1_cmp_3140.stop();
	taco::util::TimeResults res_1_cmp_3140 = timer_1_cmp_3140.getResult();
	cout << " | 1_cmp_3140 ";
	cout << " | "<< res_1_cmp_3140 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_140;
	timer_2_cmp_140.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_140);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_140);
	timer_2_cmp_140.stop();
	taco::util::TimeResults res_2_cmp_140 = timer_2_cmp_140.getResult();
	cout << " | 2_cmp_140 ";
	cout << " | "<< res_2_cmp_140 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_40;
	timer_3_cmp_40.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_40);
	timer_3_cmp_40.stop();
	taco::util::TimeResults res_3_cmp_40 = timer_3_cmp_40.getResult();
	cout << " | 3_cmp_40 ";
	cout << " | "<< res_3_cmp_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 1, 4, 0)
int transpose_coo_23140_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 1, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 3, 4, 0, 1)
	taco::util::Timer timer_0_cmp_23401;
	timer_0_cmp_23401.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23401);
	timer_0_cmp_23401.stop();
	taco::util::TimeResults res_0_cmp_23401 = timer_0_cmp_23401.getResult();
	cout << " | 0_cmp_23401 ";
	cout << " | "<< res_0_cmp_23401 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_3401;
	timer_1_cmp_3401.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3401);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3401);
	timer_1_cmp_3401.stop();
	taco::util::TimeResults res_1_cmp_3401 = timer_1_cmp_3401.getResult();
	cout << " | 1_cmp_3401 ";
	cout << " | "<< res_1_cmp_3401 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_401;
	timer_2_cmp_401.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_401);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_401);
	timer_2_cmp_401.stop();
	taco::util::TimeResults res_2_cmp_401 = timer_2_cmp_401.getResult();
	cout << " | 2_cmp_401 ";
	cout << " | "<< res_2_cmp_401 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_01;
	timer_3_cmp_01.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_01);
	timer_3_cmp_01.stop();
	taco::util::TimeResults res_3_cmp_01 = timer_3_cmp_01.getResult();
	cout << " | 3_cmp_01 ";
	cout << " | "<< res_3_cmp_01 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 0, 1)
int transpose_coo_23401_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 3, 4, 1, 0)
	taco::util::Timer timer_0_cmp_23410;
	timer_0_cmp_23410.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_23410);
	timer_0_cmp_23410.stop();
	taco::util::TimeResults res_0_cmp_23410 = timer_0_cmp_23410.getResult();
	cout << " | 0_cmp_23410 ";
	cout << " | "<< res_0_cmp_23410 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_3410;
	timer_1_cmp_3410.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3410);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3410);
	timer_1_cmp_3410.stop();
	taco::util::TimeResults res_1_cmp_3410 = timer_1_cmp_3410.getResult();
	cout << " | 1_cmp_3410 ";
	cout << " | "<< res_1_cmp_3410 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_410;
	timer_2_cmp_410.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_410);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_410);
	timer_2_cmp_410.stop();
	taco::util::TimeResults res_2_cmp_410 = timer_2_cmp_410.getResult();
	cout << " | 2_cmp_410 ";
	cout << " | "<< res_2_cmp_410 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_10;
	timer_3_cmp_10.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_10);
	timer_3_cmp_10.stop();
	taco::util::TimeResults res_3_cmp_10 = timer_3_cmp_10.getResult();
	cout << " | 3_cmp_10 ";
	cout << " | "<< res_3_cmp_10 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 3, 4, 1, 0)
int transpose_coo_23410_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 3, 4, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 4, 0, 1, 3)
	taco::util::Timer timer_0_cmp_24013;
	timer_0_cmp_24013.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24013);
	timer_0_cmp_24013.stop();
	taco::util::TimeResults res_0_cmp_24013 = timer_0_cmp_24013.getResult();
	cout << " | 0_cmp_24013 ";
	cout << " | "<< res_0_cmp_24013 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_4013;
	timer_1_cmp_4013.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4013);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4013);
	timer_1_cmp_4013.stop();
	taco::util::TimeResults res_1_cmp_4013 = timer_1_cmp_4013.getResult();
	cout << " | 1_cmp_4013 ";
	cout << " | "<< res_1_cmp_4013 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_013;
	timer_2_cmp_013.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_013);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_013);
	timer_2_cmp_013.stop();
	taco::util::TimeResults res_2_cmp_013 = timer_2_cmp_013.getResult();
	cout << " | 2_cmp_013 ";
	cout << " | "<< res_2_cmp_013 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_13;
	timer_3_cmp_13.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_13);
	timer_3_cmp_13.stop();
	taco::util::TimeResults res_3_cmp_13 = timer_3_cmp_13.getResult();
	cout << " | 3_cmp_13 ";
	cout << " | "<< res_3_cmp_13 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 1, 3)
int transpose_coo_24013_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 4, 0, 3, 1)
	taco::util::Timer timer_0_cmp_24031;
	timer_0_cmp_24031.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24031);
	timer_0_cmp_24031.stop();
	taco::util::TimeResults res_0_cmp_24031 = timer_0_cmp_24031.getResult();
	cout << " | 0_cmp_24031 ";
	cout << " | "<< res_0_cmp_24031 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_4031;
	timer_1_cmp_4031.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4031);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4031);
	timer_1_cmp_4031.stop();
	taco::util::TimeResults res_1_cmp_4031 = timer_1_cmp_4031.getResult();
	cout << " | 1_cmp_4031 ";
	cout << " | "<< res_1_cmp_4031 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_031;
	timer_2_cmp_031.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_031);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_031);
	timer_2_cmp_031.stop();
	taco::util::TimeResults res_2_cmp_031 = timer_2_cmp_031.getResult();
	cout << " | 2_cmp_031 ";
	cout << " | "<< res_2_cmp_031 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_31;
	timer_3_cmp_31.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_31);
	timer_3_cmp_31.stop();
	taco::util::TimeResults res_3_cmp_31 = timer_3_cmp_31.getResult();
	cout << " | 3_cmp_31 ";
	cout << " | "<< res_3_cmp_31 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 4, 0]
	taco::util::Timer timer_3240;
	timer_3240.start();
	// Create buckets and quotient
	int *bucket_3240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3240 = (int *)malloc(c_size*sizeof(int));
	int current_3240 = 0;
	bucket_3240[0] = 0;
	quotient_3240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		bucket_3240[i] = current_3240;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3240[i];
		B3_count[idx3]--;
	}
	free(bucket_3240);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3240[perm[i]]] = C_coords_scratch[i];
		quotient_3240[perm[i]] ++;
	}
	free(quotient_3240);
	timer_3240.stop();
	taco::util::TimeResults res_3240 = timer_3240.getResult();
	cout << " , (3, [2, 4, 0]) ";
	cout << " , "<< res_3240 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 0, 3, 1)
int transpose_coo_24031_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 0, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Fix and sort on [2, 4, 0]
	taco::util::Timer timer_3240;
	timer_3240.start();
	// Create buckets and quotient
	int *bucket_3240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3240 = (int *)malloc(c_size*sizeof(int));
	int current_3240 = 0;
	bucket_3240[0] = 0;
	quotient_3240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3240++;
			quotient_3240[current_3240] = i;
		}
		bucket_3240[i] = current_3240;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3240[i];
		B3_count[idx3]--;
	}
	free(bucket_3240);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3240[perm[i]]] = C_coords_scratch[i];
		quotient_3240[perm[i]] ++;
	}
	free(quotient_3240);
	timer_3240.stop();
	taco::util::TimeResults res_3240 = timer_3240.getResult();
	cout << " , (3, [2, 4, 0]) ";
	cout << " , "<< res_3240 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 4, 1, 0, 3)
	taco::util::Timer timer_0_cmp_24103;
	timer_0_cmp_24103.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24103);
	timer_0_cmp_24103.stop();
	taco::util::TimeResults res_0_cmp_24103 = timer_0_cmp_24103.getResult();
	cout << " | 0_cmp_24103 ";
	cout << " | "<< res_0_cmp_24103 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_4103;
	timer_1_cmp_4103.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4103);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4103);
	timer_1_cmp_4103.stop();
	taco::util::TimeResults res_1_cmp_4103 = timer_1_cmp_4103.getResult();
	cout << " | 1_cmp_4103 ";
	cout << " | "<< res_1_cmp_4103 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_103;
	timer_2_cmp_103.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_103);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_103);
	timer_2_cmp_103.stop();
	taco::util::TimeResults res_2_cmp_103 = timer_2_cmp_103.getResult();
	cout << " | 2_cmp_103 ";
	cout << " | "<< res_2_cmp_103 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_03;
	timer_3_cmp_03.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_03);
	timer_3_cmp_03.stop();
	taco::util::TimeResults res_3_cmp_03 = timer_3_cmp_03.getResult();
	cout << " | 3_cmp_03 ";
	cout << " | "<< res_3_cmp_03 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 0, 3)
int transpose_coo_24103_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 4, 1, 3, 0)
	taco::util::Timer timer_0_cmp_24130;
	timer_0_cmp_24130.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24130);
	timer_0_cmp_24130.stop();
	taco::util::TimeResults res_0_cmp_24130 = timer_0_cmp_24130.getResult();
	cout << " | 0_cmp_24130 ";
	cout << " | "<< res_0_cmp_24130 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_4130;
	timer_1_cmp_4130.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4130);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4130);
	timer_1_cmp_4130.stop();
	taco::util::TimeResults res_1_cmp_4130 = timer_1_cmp_4130.getResult();
	cout << " | 1_cmp_4130 ";
	cout << " | "<< res_1_cmp_4130 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_130;
	timer_2_cmp_130.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_130);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_130);
	timer_2_cmp_130.stop();
	taco::util::TimeResults res_2_cmp_130 = timer_2_cmp_130.getResult();
	cout << " | 2_cmp_130 ";
	cout << " | "<< res_2_cmp_130 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_30;
	timer_3_cmp_30.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_30);
	timer_3_cmp_30.stop();
	taco::util::TimeResults res_3_cmp_30 = timer_3_cmp_30.getResult();
	cout << " | 3_cmp_30 ";
	cout << " | "<< res_3_cmp_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 1, 3, 0)
int transpose_coo_24130_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 1, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 4, 3, 0, 1)
	taco::util::Timer timer_0_cmp_24301;
	timer_0_cmp_24301.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24301);
	timer_0_cmp_24301.stop();
	taco::util::TimeResults res_0_cmp_24301 = timer_0_cmp_24301.getResult();
	cout << " | 0_cmp_24301 ";
	cout << " | "<< res_0_cmp_24301 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_4301;
	timer_1_cmp_4301.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4301);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4301);
	timer_1_cmp_4301.stop();
	taco::util::TimeResults res_1_cmp_4301 = timer_1_cmp_4301.getResult();
	cout << " | 1_cmp_4301 ";
	cout << " | "<< res_1_cmp_4301 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_301;
	timer_2_cmp_301.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_301);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_301);
	timer_2_cmp_301.stop();
	taco::util::TimeResults res_2_cmp_301 = timer_2_cmp_301.getResult();
	cout << " | 2_cmp_301 ";
	cout << " | "<< res_2_cmp_301 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_01;
	timer_3_cmp_01.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_01);
	timer_3_cmp_01.stop();
	taco::util::TimeResults res_3_cmp_01 = timer_3_cmp_01.getResult();
	cout << " | 3_cmp_01 ";
	cout << " | "<< res_3_cmp_01 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 0, 1)
int transpose_coo_24301_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (2, 4, 3, 1, 0)
	taco::util::Timer timer_0_cmp_24310;
	timer_0_cmp_24310.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_24310);
	timer_0_cmp_24310.stop();
	taco::util::TimeResults res_0_cmp_24310 = timer_0_cmp_24310.getResult();
	cout << " | 0_cmp_24310 ";
	cout << " | "<< res_0_cmp_24310 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1_cmp_4310;
	timer_1_cmp_4310.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4310);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4310);
	timer_1_cmp_4310.stop();
	taco::util::TimeResults res_1_cmp_4310 = timer_1_cmp_4310.getResult();
	cout << " | 1_cmp_4310 ";
	cout << " | "<< res_1_cmp_4310 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_2_cmp_310;
	timer_2_cmp_310.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_310);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_310);
	timer_2_cmp_310.stop();
	taco::util::TimeResults res_2_cmp_310 = timer_2_cmp_310.getResult();
	cout << " | 2_cmp_310 ";
	cout << " | "<< res_2_cmp_310 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3_cmp_10;
	timer_3_cmp_10.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_10);
	timer_3_cmp_10.stop();
	taco::util::TimeResults res_3_cmp_10 = timer_3_cmp_10.getResult();
	cout << " | 3_cmp_10 ";
	cout << " | "<< res_3_cmp_10 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (2, 4, 3, 1, 0)
int transpose_coo_24310_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (2, 4, 3, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 0, 1, 2, 4)
	taco::util::Timer timer_0_cmp_30124;
	timer_0_cmp_30124.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30124);
	timer_0_cmp_30124.stop();
	taco::util::TimeResults res_0_cmp_30124 = timer_0_cmp_30124.getResult();
	cout << " | 0_cmp_30124 ";
	cout << " | "<< res_0_cmp_30124 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_0124;
	timer_1_cmp_0124.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0124);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0124);
	timer_1_cmp_0124.stop();
	taco::util::TimeResults res_1_cmp_0124 = timer_1_cmp_0124.getResult();
	cout << " | 1_cmp_0124 ";
	cout << " | "<< res_1_cmp_0124 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_124;
	timer_2_cmp_124.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_124);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_124);
	timer_2_cmp_124.stop();
	taco::util::TimeResults res_2_cmp_124 = timer_2_cmp_124.getResult();
	cout << " | 2_cmp_124 ";
	cout << " | "<< res_2_cmp_124 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_24;
	timer_3_cmp_24.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_24);
	timer_3_cmp_24.stop();
	taco::util::TimeResults res_3_cmp_24 = timer_3_cmp_24.getResult();
	cout << " | 3_cmp_24 ";
	cout << " | "<< res_3_cmp_24 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 2, 4)
int transpose_coo_30124_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 0, 1, 4, 2)
	taco::util::Timer timer_0_cmp_30142;
	timer_0_cmp_30142.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30142);
	timer_0_cmp_30142.stop();
	taco::util::TimeResults res_0_cmp_30142 = timer_0_cmp_30142.getResult();
	cout << " | 0_cmp_30142 ";
	cout << " | "<< res_0_cmp_30142 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_0142;
	timer_1_cmp_0142.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0142);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0142);
	timer_1_cmp_0142.stop();
	taco::util::TimeResults res_1_cmp_0142 = timer_1_cmp_0142.getResult();
	cout << " | 1_cmp_0142 ";
	cout << " | "<< res_1_cmp_0142 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_142;
	timer_2_cmp_142.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_142);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_142);
	timer_2_cmp_142.stop();
	taco::util::TimeResults res_2_cmp_142 = timer_2_cmp_142.getResult();
	cout << " | 2_cmp_142 ";
	cout << " | "<< res_2_cmp_142 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_42;
	timer_3_cmp_42.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_42);
	timer_3_cmp_42.stop();
	taco::util::TimeResults res_3_cmp_42 = timer_3_cmp_42.getResult();
	cout << " | 3_cmp_42 ";
	cout << " | "<< res_3_cmp_42 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0, 1]
	taco::util::Timer timer_4301;
	timer_4301.start();
	// Create buckets and quotient
	int *bucket_4301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4301 = (int *)malloc(c_size*sizeof(int));
	int current_4301 = 0;
	bucket_4301[0] = 0;
	quotient_4301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		bucket_4301[i] = current_4301;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4301[i];
		B4_count[idx4]--;
	}
	free(bucket_4301);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4301[perm[i]]] = C_coords_scratch[i];
		quotient_4301[perm[i]] ++;
	}
	free(quotient_4301);
	timer_4301.stop();
	taco::util::TimeResults res_4301 = timer_4301.getResult();
	cout << " , (4, [3, 0, 1]) ";
	cout << " , "<< res_4301 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 1, 4, 2)
int transpose_coo_30142_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 1, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0, 1]
	taco::util::Timer timer_4301;
	timer_4301.start();
	// Create buckets and quotient
	int *bucket_4301 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4301 = (int *)malloc(c_size*sizeof(int));
	int current_4301 = 0;
	bucket_4301[0] = 0;
	quotient_4301[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4301++;
			quotient_4301[current_4301] = i;
		}
		bucket_4301[i] = current_4301;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4301[i];
		B4_count[idx4]--;
	}
	free(bucket_4301);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4301[perm[i]]] = C_coords_scratch[i];
		quotient_4301[perm[i]] ++;
	}
	free(quotient_4301);
	timer_4301.stop();
	taco::util::TimeResults res_4301 = timer_4301.getResult();
	cout << " , (4, [3, 0, 1]) ";
	cout << " , "<< res_4301 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 0, 2, 1, 4)
	taco::util::Timer timer_0_cmp_30214;
	timer_0_cmp_30214.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30214);
	timer_0_cmp_30214.stop();
	taco::util::TimeResults res_0_cmp_30214 = timer_0_cmp_30214.getResult();
	cout << " | 0_cmp_30214 ";
	cout << " | "<< res_0_cmp_30214 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_0214;
	timer_1_cmp_0214.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0214);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0214);
	timer_1_cmp_0214.stop();
	taco::util::TimeResults res_1_cmp_0214 = timer_1_cmp_0214.getResult();
	cout << " | 1_cmp_0214 ";
	cout << " | "<< res_1_cmp_0214 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_214;
	timer_2_cmp_214.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_214);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_214);
	timer_2_cmp_214.stop();
	taco::util::TimeResults res_2_cmp_214 = timer_2_cmp_214.getResult();
	cout << " | 2_cmp_214 ";
	cout << " | "<< res_2_cmp_214 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	taco::util::Timer timer_3_cmp_14;
	timer_3_cmp_14.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_14);
	timer_3_cmp_14.stop();
	taco::util::TimeResults res_3_cmp_14 = timer_3_cmp_14.getResult();
	cout << " | 3_cmp_14 ";
	cout << " | "<< res_3_cmp_14 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 1, 4)
int transpose_coo_30214_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 0, 2, 4, 1)
	taco::util::Timer timer_0_cmp_30241;
	timer_0_cmp_30241.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30241);
	timer_0_cmp_30241.stop();
	taco::util::TimeResults res_0_cmp_30241 = timer_0_cmp_30241.getResult();
	cout << " | 0_cmp_30241 ";
	cout << " | "<< res_0_cmp_30241 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_0241;
	timer_1_cmp_0241.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0241);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0241);
	timer_1_cmp_0241.stop();
	taco::util::TimeResults res_1_cmp_0241 = timer_1_cmp_0241.getResult();
	cout << " | 1_cmp_0241 ";
	cout << " | "<< res_1_cmp_0241 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_241;
	timer_2_cmp_241.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_241);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_241);
	timer_2_cmp_241.stop();
	taco::util::TimeResults res_2_cmp_241 = timer_2_cmp_241.getResult();
	cout << " | 2_cmp_241 ";
	cout << " | "<< res_2_cmp_241 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	taco::util::Timer timer_3_cmp_41;
	timer_3_cmp_41.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_41);
	timer_3_cmp_41.stop();
	taco::util::TimeResults res_3_cmp_41 = timer_3_cmp_41.getResult();
	cout << " | 3_cmp_41 ";
	cout << " | "<< res_3_cmp_41 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 2, 4, 1)
int transpose_coo_30241_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 2, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 0, 4, 1, 2)
	taco::util::Timer timer_0_cmp_30412;
	timer_0_cmp_30412.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30412);
	timer_0_cmp_30412.stop();
	taco::util::TimeResults res_0_cmp_30412 = timer_0_cmp_30412.getResult();
	cout << " | 0_cmp_30412 ";
	cout << " | "<< res_0_cmp_30412 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_0412;
	timer_1_cmp_0412.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0412);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0412);
	timer_1_cmp_0412.stop();
	taco::util::TimeResults res_1_cmp_0412 = timer_1_cmp_0412.getResult();
	cout << " | 1_cmp_0412 ";
	cout << " | "<< res_1_cmp_0412 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_412;
	timer_2_cmp_412.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_412);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_412);
	timer_2_cmp_412.stop();
	taco::util::TimeResults res_2_cmp_412 = timer_2_cmp_412.getResult();
	cout << " | 2_cmp_412 ";
	cout << " | "<< res_2_cmp_412 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	taco::util::Timer timer_3_cmp_12;
	timer_3_cmp_12.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_12);
	timer_3_cmp_12.stop();
	taco::util::TimeResults res_3_cmp_12 = timer_3_cmp_12.getResult();
	cout << " | 3_cmp_12 ";
	cout << " | "<< res_3_cmp_12 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 1, 2)
int transpose_coo_30412_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 0, 4, 2, 1)
	taco::util::Timer timer_0_cmp_30421;
	timer_0_cmp_30421.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_30421);
	timer_0_cmp_30421.stop();
	taco::util::TimeResults res_0_cmp_30421 = timer_0_cmp_30421.getResult();
	cout << " | 0_cmp_30421 ";
	cout << " | "<< res_0_cmp_30421 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_0421;
	timer_1_cmp_0421.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0421);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0421);
	timer_1_cmp_0421.stop();
	taco::util::TimeResults res_1_cmp_0421 = timer_1_cmp_0421.getResult();
	cout << " | 1_cmp_0421 ";
	cout << " | "<< res_1_cmp_0421 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_421;
	timer_2_cmp_421.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_421);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_421);
	timer_2_cmp_421.stop();
	taco::util::TimeResults res_2_cmp_421 = timer_2_cmp_421.getResult();
	cout << " | 2_cmp_421 ";
	cout << " | "<< res_2_cmp_421 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	taco::util::Timer timer_3_cmp_21;
	timer_3_cmp_21.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_21);
	timer_3_cmp_21.stop();
	taco::util::TimeResults res_3_cmp_21 = timer_3_cmp_21.getResult();
	cout << " | 3_cmp_21 ";
	cout << " | "<< res_3_cmp_21 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 0, 4, 2, 1)
int transpose_coo_30421_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 0, 4, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_230;
	timer_230.start();
	// Create buckets and quotient
	int *bucket_230 = (int *)malloc(c_size*sizeof(int));
	int *quotient_230 = (int *)malloc(c_size*sizeof(int));
	int current_230 = 0;
	bucket_230[0] = 0;
	quotient_230[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_230++;
			quotient_230[current_230] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_230++;
			quotient_230[current_230] = i;
		}
		bucket_230[i] = current_230;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_230[i];
		B2_count[idx2]--;
	}
	free(bucket_230);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_230[perm[i]]] = C_coords_scratch[i];
		quotient_230[perm[i]] ++;
	}
	free(quotient_230);
	timer_230.stop();
	taco::util::TimeResults res_230 = timer_230.getResult();
	cout << " , (2, [3, 0]) ";
	cout << " , "<< res_230 ;
	// Fix and sort on [3, 0]
	taco::util::Timer timer_430;
	timer_430.start();
	// Create buckets and quotient
	int *bucket_430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_430 = (int *)malloc(c_size*sizeof(int));
	int current_430 = 0;
	bucket_430[0] = 0;
	quotient_430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_430++;
			quotient_430[current_430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_430++;
			quotient_430[current_430] = i;
		}
		bucket_430[i] = current_430;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_430[i];
		B4_count[idx4]--;
	}
	free(bucket_430);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_430[perm[i]]] = C_coords_scratch[i];
		quotient_430[perm[i]] ++;
	}
	free(quotient_430);
	timer_430.stop();
	taco::util::TimeResults res_430 = timer_430.getResult();
	cout << " , (4, [3, 0]) ";
	cout << " , "<< res_430 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 1, 0, 2, 4)
	taco::util::Timer timer_0_cmp_31024;
	timer_0_cmp_31024.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31024);
	timer_0_cmp_31024.stop();
	taco::util::TimeResults res_0_cmp_31024 = timer_0_cmp_31024.getResult();
	cout << " | 0_cmp_31024 ";
	cout << " | "<< res_0_cmp_31024 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_1024;
	timer_1_cmp_1024.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1024);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1024);
	timer_1_cmp_1024.stop();
	taco::util::TimeResults res_1_cmp_1024 = timer_1_cmp_1024.getResult();
	cout << " | 1_cmp_1024 ";
	cout << " | "<< res_1_cmp_1024 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_024;
	timer_2_cmp_024.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_024);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_024);
	timer_2_cmp_024.stop();
	taco::util::TimeResults res_2_cmp_024 = timer_2_cmp_024.getResult();
	cout << " | 2_cmp_024 ";
	cout << " | "<< res_2_cmp_024 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_24;
	timer_3_cmp_24.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_24);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_24);
	timer_3_cmp_24.stop();
	taco::util::TimeResults res_3_cmp_24 = timer_3_cmp_24.getResult();
	cout << " | 3_cmp_24 ";
	cout << " | "<< res_3_cmp_24 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 2, 4)
int transpose_coo_31024_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 2, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 1, 0, 4, 2)
	taco::util::Timer timer_0_cmp_31042;
	timer_0_cmp_31042.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31042);
	timer_0_cmp_31042.stop();
	taco::util::TimeResults res_0_cmp_31042 = timer_0_cmp_31042.getResult();
	cout << " | 0_cmp_31042 ";
	cout << " | "<< res_0_cmp_31042 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_1042;
	timer_1_cmp_1042.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1042);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1042);
	timer_1_cmp_1042.stop();
	taco::util::TimeResults res_1_cmp_1042 = timer_1_cmp_1042.getResult();
	cout << " | 1_cmp_1042 ";
	cout << " | "<< res_1_cmp_1042 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_042;
	timer_2_cmp_042.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_042);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_042);
	timer_2_cmp_042.stop();
	taco::util::TimeResults res_2_cmp_042 = timer_2_cmp_042.getResult();
	cout << " | 2_cmp_042 ";
	cout << " | "<< res_2_cmp_042 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_42;
	timer_3_cmp_42.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_42);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_42);
	timer_3_cmp_42.stop();
	taco::util::TimeResults res_3_cmp_42 = timer_3_cmp_42.getResult();
	cout << " | 3_cmp_42 ";
	cout << " | "<< res_3_cmp_42 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 1, 0]
	taco::util::Timer timer_4310;
	timer_4310.start();
	// Create buckets and quotient
	int *bucket_4310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4310 = (int *)malloc(c_size*sizeof(int));
	int current_4310 = 0;
	bucket_4310[0] = 0;
	quotient_4310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		bucket_4310[i] = current_4310;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4310[i];
		B4_count[idx4]--;
	}
	free(bucket_4310);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4310[perm[i]]] = C_coords_scratch[i];
		quotient_4310[perm[i]] ++;
	}
	free(quotient_4310);
	timer_4310.stop();
	taco::util::TimeResults res_4310 = timer_4310.getResult();
	cout << " , (4, [3, 1, 0]) ";
	cout << " , "<< res_4310 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 0, 4, 2)
int transpose_coo_31042_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 0, 4, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 1, 0]
	taco::util::Timer timer_4310;
	timer_4310.start();
	// Create buckets and quotient
	int *bucket_4310 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4310 = (int *)malloc(c_size*sizeof(int));
	int current_4310 = 0;
	bucket_4310[0] = 0;
	quotient_4310[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4310++;
			quotient_4310[current_4310] = i;
		}
		bucket_4310[i] = current_4310;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4310[i];
		B4_count[idx4]--;
	}
	free(bucket_4310);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4310[perm[i]]] = C_coords_scratch[i];
		quotient_4310[perm[i]] ++;
	}
	free(quotient_4310);
	timer_4310.stop();
	taco::util::TimeResults res_4310 = timer_4310.getResult();
	cout << " , (4, [3, 1, 0]) ";
	cout << " , "<< res_4310 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 1, 2, 0, 4)
	taco::util::Timer timer_0_cmp_31204;
	timer_0_cmp_31204.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31204);
	timer_0_cmp_31204.stop();
	taco::util::TimeResults res_0_cmp_31204 = timer_0_cmp_31204.getResult();
	cout << " | 0_cmp_31204 ";
	cout << " | "<< res_0_cmp_31204 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_1204;
	timer_1_cmp_1204.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1204);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1204);
	timer_1_cmp_1204.stop();
	taco::util::TimeResults res_1_cmp_1204 = timer_1_cmp_1204.getResult();
	cout << " | 1_cmp_1204 ";
	cout << " | "<< res_1_cmp_1204 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_204;
	timer_2_cmp_204.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_204);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_204);
	timer_2_cmp_204.stop();
	taco::util::TimeResults res_2_cmp_204 = timer_2_cmp_204.getResult();
	cout << " | 2_cmp_204 ";
	cout << " | "<< res_2_cmp_204 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_04;
	timer_3_cmp_04.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_04);
	timer_3_cmp_04.stop();
	taco::util::TimeResults res_3_cmp_04 = timer_3_cmp_04.getResult();
	cout << " | 3_cmp_04 ";
	cout << " | "<< res_3_cmp_04 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 0, 4)
int transpose_coo_31204_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 1, 2, 4, 0)
	taco::util::Timer timer_0_cmp_31240;
	timer_0_cmp_31240.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31240);
	timer_0_cmp_31240.stop();
	taco::util::TimeResults res_0_cmp_31240 = timer_0_cmp_31240.getResult();
	cout << " | 0_cmp_31240 ";
	cout << " | "<< res_0_cmp_31240 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_1240;
	timer_1_cmp_1240.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1240);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1240);
	timer_1_cmp_1240.stop();
	taco::util::TimeResults res_1_cmp_1240 = timer_1_cmp_1240.getResult();
	cout << " | 1_cmp_1240 ";
	cout << " | "<< res_1_cmp_1240 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_240;
	timer_2_cmp_240.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_240);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_240);
	timer_2_cmp_240.stop();
	taco::util::TimeResults res_2_cmp_240 = timer_2_cmp_240.getResult();
	cout << " | 2_cmp_240 ";
	cout << " | "<< res_2_cmp_240 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_40;
	timer_3_cmp_40.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_40);
	timer_3_cmp_40.stop();
	taco::util::TimeResults res_3_cmp_40 = timer_3_cmp_40.getResult();
	cout << " | 3_cmp_40 ";
	cout << " | "<< res_3_cmp_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 2, 4, 0)
int transpose_coo_31240_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 2, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 1, 4, 0, 2)
	taco::util::Timer timer_0_cmp_31402;
	timer_0_cmp_31402.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31402);
	timer_0_cmp_31402.stop();
	taco::util::TimeResults res_0_cmp_31402 = timer_0_cmp_31402.getResult();
	cout << " | 0_cmp_31402 ";
	cout << " | "<< res_0_cmp_31402 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_1402;
	timer_1_cmp_1402.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1402);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1402);
	timer_1_cmp_1402.stop();
	taco::util::TimeResults res_1_cmp_1402 = timer_1_cmp_1402.getResult();
	cout << " | 1_cmp_1402 ";
	cout << " | "<< res_1_cmp_1402 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_402;
	timer_2_cmp_402.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_402);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_402);
	timer_2_cmp_402.stop();
	taco::util::TimeResults res_2_cmp_402 = timer_2_cmp_402.getResult();
	cout << " | 2_cmp_402 ";
	cout << " | "<< res_2_cmp_402 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_02;
	timer_3_cmp_02.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_02);
	timer_3_cmp_02.stop();
	taco::util::TimeResults res_3_cmp_02 = timer_3_cmp_02.getResult();
	cout << " | 3_cmp_02 ";
	cout << " | "<< res_3_cmp_02 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 0, 2)
int transpose_coo_31402_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 1, 4, 2, 0)
	taco::util::Timer timer_0_cmp_31420;
	timer_0_cmp_31420.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_31420);
	timer_0_cmp_31420.stop();
	taco::util::TimeResults res_0_cmp_31420 = timer_0_cmp_31420.getResult();
	cout << " | 0_cmp_31420 ";
	cout << " | "<< res_0_cmp_31420 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_1420;
	timer_1_cmp_1420.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1420);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1420);
	timer_1_cmp_1420.stop();
	taco::util::TimeResults res_1_cmp_1420 = timer_1_cmp_1420.getResult();
	cout << " | 1_cmp_1420 ";
	cout << " | "<< res_1_cmp_1420 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_420;
	timer_2_cmp_420.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_420);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_420);
	timer_2_cmp_420.stop();
	taco::util::TimeResults res_2_cmp_420 = timer_2_cmp_420.getResult();
	cout << " | 2_cmp_420 ";
	cout << " | "<< res_2_cmp_420 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_20;
	timer_3_cmp_20.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_20);
	timer_3_cmp_20.stop();
	taco::util::TimeResults res_3_cmp_20 = timer_3_cmp_20.getResult();
	cout << " | 3_cmp_20 ";
	cout << " | "<< res_3_cmp_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 1, 4, 2, 0)
int transpose_coo_31420_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 1, 4, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 2, 0, 1, 4)
	taco::util::Timer timer_0_cmp_32014;
	timer_0_cmp_32014.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32014);
	timer_0_cmp_32014.stop();
	taco::util::TimeResults res_0_cmp_32014 = timer_0_cmp_32014.getResult();
	cout << " | 0_cmp_32014 ";
	cout << " | "<< res_0_cmp_32014 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_2014;
	timer_1_cmp_2014.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2014);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2014);
	timer_1_cmp_2014.stop();
	taco::util::TimeResults res_1_cmp_2014 = timer_1_cmp_2014.getResult();
	cout << " | 1_cmp_2014 ";
	cout << " | "<< res_1_cmp_2014 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_014;
	timer_2_cmp_014.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_014);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_014);
	timer_2_cmp_014.stop();
	taco::util::TimeResults res_2_cmp_014 = timer_2_cmp_014.getResult();
	cout << " | 2_cmp_014 ";
	cout << " | "<< res_2_cmp_014 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_14;
	timer_3_cmp_14.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_14);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_14);
	timer_3_cmp_14.stop();
	taco::util::TimeResults res_3_cmp_14 = timer_3_cmp_14.getResult();
	cout << " | 3_cmp_14 ";
	cout << " | "<< res_3_cmp_14 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 1, 4)
int transpose_coo_32014_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 1, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 2, 0, 4, 1)
	taco::util::Timer timer_0_cmp_32041;
	timer_0_cmp_32041.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32041);
	timer_0_cmp_32041.stop();
	taco::util::TimeResults res_0_cmp_32041 = timer_0_cmp_32041.getResult();
	cout << " | 0_cmp_32041 ";
	cout << " | "<< res_0_cmp_32041 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_2041;
	timer_1_cmp_2041.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2041);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2041);
	timer_1_cmp_2041.stop();
	taco::util::TimeResults res_1_cmp_2041 = timer_1_cmp_2041.getResult();
	cout << " | 1_cmp_2041 ";
	cout << " | "<< res_1_cmp_2041 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_041;
	timer_2_cmp_041.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_041);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_041);
	timer_2_cmp_041.stop();
	taco::util::TimeResults res_2_cmp_041 = timer_2_cmp_041.getResult();
	cout << " | 2_cmp_041 ";
	cout << " | "<< res_2_cmp_041 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_41;
	timer_3_cmp_41.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_41);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_41);
	timer_3_cmp_41.stop();
	taco::util::TimeResults res_3_cmp_41 = timer_3_cmp_41.getResult();
	cout << " | 3_cmp_41 ";
	cout << " | "<< res_3_cmp_41 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 2, 0]
	taco::util::Timer timer_4320;
	timer_4320.start();
	// Create buckets and quotient
	int *bucket_4320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4320 = (int *)malloc(c_size*sizeof(int));
	int current_4320 = 0;
	bucket_4320[0] = 0;
	quotient_4320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		bucket_4320[i] = current_4320;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4320[i];
		B4_count[idx4]--;
	}
	free(bucket_4320);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4320[perm[i]]] = C_coords_scratch[i];
		quotient_4320[perm[i]] ++;
	}
	free(quotient_4320);
	timer_4320.stop();
	taco::util::TimeResults res_4320 = timer_4320.getResult();
	cout << " , (4, [3, 2, 0]) ";
	cout << " , "<< res_4320 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 0, 4, 1)
int transpose_coo_32041_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 0, 4, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 2, 0]
	taco::util::Timer timer_4320;
	timer_4320.start();
	// Create buckets and quotient
	int *bucket_4320 = (int *)malloc(c_size*sizeof(int));
	int *quotient_4320 = (int *)malloc(c_size*sizeof(int));
	int current_4320 = 0;
	bucket_4320[0] = 0;
	quotient_4320[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_4320++;
			quotient_4320[current_4320] = i;
		}
		bucket_4320[i] = current_4320;
	}

	// Histogram sort on mode 4 into the permutation array
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_4320[i];
		B4_count[idx4]--;
	}
	free(bucket_4320);
	free(B4_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_4320[perm[i]]] = C_coords_scratch[i];
		quotient_4320[perm[i]] ++;
	}
	free(quotient_4320);
	timer_4320.stop();
	taco::util::TimeResults res_4320 = timer_4320.getResult();
	cout << " , (4, [3, 2, 0]) ";
	cout << " , "<< res_4320 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 2, 1, 0, 4)
	taco::util::Timer timer_0_cmp_32104;
	timer_0_cmp_32104.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32104);
	timer_0_cmp_32104.stop();
	taco::util::TimeResults res_0_cmp_32104 = timer_0_cmp_32104.getResult();
	cout << " | 0_cmp_32104 ";
	cout << " | "<< res_0_cmp_32104 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_2104;
	timer_1_cmp_2104.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2104);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2104);
	timer_1_cmp_2104.stop();
	taco::util::TimeResults res_1_cmp_2104 = timer_1_cmp_2104.getResult();
	cout << " | 1_cmp_2104 ";
	cout << " | "<< res_1_cmp_2104 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_104;
	timer_2_cmp_104.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_104);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_104);
	timer_2_cmp_104.stop();
	taco::util::TimeResults res_2_cmp_104 = timer_2_cmp_104.getResult();
	cout << " | 2_cmp_104 ";
	cout << " | "<< res_2_cmp_104 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_04;
	timer_3_cmp_04.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_04);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_04);
	timer_3_cmp_04.stop();
	taco::util::TimeResults res_3_cmp_04 = timer_3_cmp_04.getResult();
	cout << " | 3_cmp_04 ";
	cout << " | "<< res_3_cmp_04 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_4;
	timer_4_cmp_4.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4);
	timer_4_cmp_4.stop();
	taco::util::TimeResults res_4_cmp_4 = timer_4_cmp_4.getResult();
	cout << " | 4_cmp_4 ";
	cout << " | "<< res_4_cmp_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 0, 4)
int transpose_coo_32104_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 0, 4)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 2, 1, 4, 0)
	taco::util::Timer timer_0_cmp_32140;
	timer_0_cmp_32140.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32140);
	timer_0_cmp_32140.stop();
	taco::util::TimeResults res_0_cmp_32140 = timer_0_cmp_32140.getResult();
	cout << " | 0_cmp_32140 ";
	cout << " | "<< res_0_cmp_32140 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_2140;
	timer_1_cmp_2140.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2140);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2140);
	timer_1_cmp_2140.stop();
	taco::util::TimeResults res_1_cmp_2140 = timer_1_cmp_2140.getResult();
	cout << " | 1_cmp_2140 ";
	cout << " | "<< res_1_cmp_2140 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_140;
	timer_2_cmp_140.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_140);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_140);
	timer_2_cmp_140.stop();
	taco::util::TimeResults res_2_cmp_140 = timer_2_cmp_140.getResult();
	cout << " | 2_cmp_140 ";
	cout << " | "<< res_2_cmp_140 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_40;
	timer_3_cmp_40.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_40);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_40);
	timer_3_cmp_40.stop();
	taco::util::TimeResults res_3_cmp_40 = timer_3_cmp_40.getResult();
	cout << " | 3_cmp_40 ";
	cout << " | "<< res_3_cmp_40 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 1, 4, 0)
int transpose_coo_32140_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 1, 4, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 2, 4, 0, 1)
	taco::util::Timer timer_0_cmp_32401;
	timer_0_cmp_32401.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32401);
	timer_0_cmp_32401.stop();
	taco::util::TimeResults res_0_cmp_32401 = timer_0_cmp_32401.getResult();
	cout << " | 0_cmp_32401 ";
	cout << " | "<< res_0_cmp_32401 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_2401;
	timer_1_cmp_2401.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2401);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2401);
	timer_1_cmp_2401.stop();
	taco::util::TimeResults res_1_cmp_2401 = timer_1_cmp_2401.getResult();
	cout << " | 1_cmp_2401 ";
	cout << " | "<< res_1_cmp_2401 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_401;
	timer_2_cmp_401.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_401);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_401);
	timer_2_cmp_401.stop();
	taco::util::TimeResults res_2_cmp_401 = timer_2_cmp_401.getResult();
	cout << " | 2_cmp_401 ";
	cout << " | "<< res_2_cmp_401 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_01;
	timer_3_cmp_01.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_01);
	timer_3_cmp_01.stop();
	taco::util::TimeResults res_3_cmp_01 = timer_3_cmp_01.getResult();
	cout << " | 3_cmp_01 ";
	cout << " | "<< res_3_cmp_01 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 0, 1)
int transpose_coo_32401_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 2, 4, 1, 0)
	taco::util::Timer timer_0_cmp_32410;
	timer_0_cmp_32410.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_32410);
	timer_0_cmp_32410.stop();
	taco::util::TimeResults res_0_cmp_32410 = timer_0_cmp_32410.getResult();
	cout << " | 0_cmp_32410 ";
	cout << " | "<< res_0_cmp_32410 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_2410;
	timer_1_cmp_2410.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2410);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2410);
	timer_1_cmp_2410.stop();
	taco::util::TimeResults res_1_cmp_2410 = timer_1_cmp_2410.getResult();
	cout << " | 1_cmp_2410 ";
	cout << " | "<< res_1_cmp_2410 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_410;
	timer_2_cmp_410.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_410);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_410);
	timer_2_cmp_410.stop();
	taco::util::TimeResults res_2_cmp_410 = timer_2_cmp_410.getResult();
	cout << " | 2_cmp_410 ";
	cout << " | "<< res_2_cmp_410 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_10;
	timer_3_cmp_10.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_10);
	timer_3_cmp_10.stop();
	taco::util::TimeResults res_3_cmp_10 = timer_3_cmp_10.getResult();
	cout << " | 3_cmp_10 ";
	cout << " | "<< res_3_cmp_10 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 2, 4, 1, 0)
int transpose_coo_32410_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 2, 4, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 4, 0, 1, 2)
	taco::util::Timer timer_0_cmp_34012;
	timer_0_cmp_34012.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34012);
	timer_0_cmp_34012.stop();
	taco::util::TimeResults res_0_cmp_34012 = timer_0_cmp_34012.getResult();
	cout << " | 0_cmp_34012 ";
	cout << " | "<< res_0_cmp_34012 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_4012;
	timer_1_cmp_4012.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4012);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4012);
	timer_1_cmp_4012.stop();
	taco::util::TimeResults res_1_cmp_4012 = timer_1_cmp_4012.getResult();
	cout << " | 1_cmp_4012 ";
	cout << " | "<< res_1_cmp_4012 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_012;
	timer_2_cmp_012.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_012);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_012);
	timer_2_cmp_012.stop();
	taco::util::TimeResults res_2_cmp_012 = timer_2_cmp_012.getResult();
	cout << " | 2_cmp_012 ";
	cout << " | "<< res_2_cmp_012 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_12;
	timer_3_cmp_12.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_12);
	timer_3_cmp_12.stop();
	taco::util::TimeResults res_3_cmp_12 = timer_3_cmp_12.getResult();
	cout << " | 3_cmp_12 ";
	cout << " | "<< res_3_cmp_12 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 1, 2)
int transpose_coo_34012_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 4, 0, 2, 1)
	taco::util::Timer timer_0_cmp_34021;
	timer_0_cmp_34021.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34021);
	timer_0_cmp_34021.stop();
	taco::util::TimeResults res_0_cmp_34021 = timer_0_cmp_34021.getResult();
	cout << " | 0_cmp_34021 ";
	cout << " | "<< res_0_cmp_34021 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_4021;
	timer_1_cmp_4021.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4021);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4021);
	timer_1_cmp_4021.stop();
	taco::util::TimeResults res_1_cmp_4021 = timer_1_cmp_4021.getResult();
	cout << " | 1_cmp_4021 ";
	cout << " | "<< res_1_cmp_4021 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_021;
	timer_2_cmp_021.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_021);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_021);
	timer_2_cmp_021.stop();
	taco::util::TimeResults res_2_cmp_021 = timer_2_cmp_021.getResult();
	cout << " | 2_cmp_021 ";
	cout << " | "<< res_2_cmp_021 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_21;
	timer_3_cmp_21.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_21);
	timer_3_cmp_21.stop();
	taco::util::TimeResults res_3_cmp_21 = timer_3_cmp_21.getResult();
	cout << " | 3_cmp_21 ";
	cout << " | "<< res_3_cmp_21 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 4, 0]
	taco::util::Timer timer_2340;
	timer_2340.start();
	// Create buckets and quotient
	int *bucket_2340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2340 = (int *)malloc(c_size*sizeof(int));
	int current_2340 = 0;
	bucket_2340[0] = 0;
	quotient_2340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		bucket_2340[i] = current_2340;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2340[i];
		B2_count[idx2]--;
	}
	free(bucket_2340);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2340[perm[i]]] = C_coords_scratch[i];
		quotient_2340[perm[i]] ++;
	}
	free(quotient_2340);
	timer_2340.stop();
	taco::util::TimeResults res_2340 = timer_2340.getResult();
	cout << " , (2, [3, 4, 0]) ";
	cout << " , "<< res_2340 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 0, 2, 1)
int transpose_coo_34021_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 0, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Fix and sort on [3, 4, 0]
	taco::util::Timer timer_2340;
	timer_2340.start();
	// Create buckets and quotient
	int *bucket_2340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2340 = (int *)malloc(c_size*sizeof(int));
	int current_2340 = 0;
	bucket_2340[0] = 0;
	quotient_2340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2340++;
			quotient_2340[current_2340] = i;
		}
		bucket_2340[i] = current_2340;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2340[i];
		B2_count[idx2]--;
	}
	free(bucket_2340);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2340[perm[i]]] = C_coords_scratch[i];
		quotient_2340[perm[i]] ++;
	}
	free(quotient_2340);
	timer_2340.stop();
	taco::util::TimeResults res_2340 = timer_2340.getResult();
	cout << " , (2, [3, 4, 0]) ";
	cout << " , "<< res_2340 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 4, 1, 0, 2)
	taco::util::Timer timer_0_cmp_34102;
	timer_0_cmp_34102.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34102);
	timer_0_cmp_34102.stop();
	taco::util::TimeResults res_0_cmp_34102 = timer_0_cmp_34102.getResult();
	cout << " | 0_cmp_34102 ";
	cout << " | "<< res_0_cmp_34102 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_4102;
	timer_1_cmp_4102.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4102);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4102);
	timer_1_cmp_4102.stop();
	taco::util::TimeResults res_1_cmp_4102 = timer_1_cmp_4102.getResult();
	cout << " | 1_cmp_4102 ";
	cout << " | "<< res_1_cmp_4102 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_102;
	timer_2_cmp_102.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_102);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_102);
	timer_2_cmp_102.stop();
	taco::util::TimeResults res_2_cmp_102 = timer_2_cmp_102.getResult();
	cout << " | 2_cmp_102 ";
	cout << " | "<< res_2_cmp_102 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_02;
	timer_3_cmp_02.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_02);
	timer_3_cmp_02.stop();
	taco::util::TimeResults res_3_cmp_02 = timer_3_cmp_02.getResult();
	cout << " | 3_cmp_02 ";
	cout << " | "<< res_3_cmp_02 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 0, 2)
int transpose_coo_34102_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 4, 1, 2, 0)
	taco::util::Timer timer_0_cmp_34120;
	timer_0_cmp_34120.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34120);
	timer_0_cmp_34120.stop();
	taco::util::TimeResults res_0_cmp_34120 = timer_0_cmp_34120.getResult();
	cout << " | 0_cmp_34120 ";
	cout << " | "<< res_0_cmp_34120 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_4120;
	timer_1_cmp_4120.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4120);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4120);
	timer_1_cmp_4120.stop();
	taco::util::TimeResults res_1_cmp_4120 = timer_1_cmp_4120.getResult();
	cout << " | 1_cmp_4120 ";
	cout << " | "<< res_1_cmp_4120 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_120;
	timer_2_cmp_120.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_120);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_120);
	timer_2_cmp_120.stop();
	taco::util::TimeResults res_2_cmp_120 = timer_2_cmp_120.getResult();
	cout << " | 2_cmp_120 ";
	cout << " | "<< res_2_cmp_120 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_20;
	timer_3_cmp_20.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_20);
	timer_3_cmp_20.stop();
	taco::util::TimeResults res_3_cmp_20 = timer_3_cmp_20.getResult();
	cout << " | 3_cmp_20 ";
	cout << " | "<< res_3_cmp_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 1, 2, 0)
int transpose_coo_34120_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 1, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 4, 2, 0, 1)
	taco::util::Timer timer_0_cmp_34201;
	timer_0_cmp_34201.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34201);
	timer_0_cmp_34201.stop();
	taco::util::TimeResults res_0_cmp_34201 = timer_0_cmp_34201.getResult();
	cout << " | 0_cmp_34201 ";
	cout << " | "<< res_0_cmp_34201 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_4201;
	timer_1_cmp_4201.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4201);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4201);
	timer_1_cmp_4201.stop();
	taco::util::TimeResults res_1_cmp_4201 = timer_1_cmp_4201.getResult();
	cout << " | 1_cmp_4201 ";
	cout << " | "<< res_1_cmp_4201 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_201;
	timer_2_cmp_201.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_201);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_201);
	timer_2_cmp_201.stop();
	taco::util::TimeResults res_2_cmp_201 = timer_2_cmp_201.getResult();
	cout << " | 2_cmp_201 ";
	cout << " | "<< res_2_cmp_201 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_01;
	timer_3_cmp_01.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_01);
	timer_3_cmp_01.stop();
	taco::util::TimeResults res_3_cmp_01 = timer_3_cmp_01.getResult();
	cout << " | 3_cmp_01 ";
	cout << " | "<< res_3_cmp_01 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 0, 1)
int transpose_coo_34201_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (3, 4, 2, 1, 0)
	taco::util::Timer timer_0_cmp_34210;
	timer_0_cmp_34210.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_34210);
	timer_0_cmp_34210.stop();
	taco::util::TimeResults res_0_cmp_34210 = timer_0_cmp_34210.getResult();
	cout << " | 0_cmp_34210 ";
	cout << " | "<< res_0_cmp_34210 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1_cmp_4210;
	timer_1_cmp_4210.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_4210);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_4210);
	timer_1_cmp_4210.stop();
	taco::util::TimeResults res_1_cmp_4210 = timer_1_cmp_4210.getResult();
	cout << " | 1_cmp_4210 ";
	cout << " | "<< res_1_cmp_4210 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2_cmp_210;
	timer_2_cmp_210.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_210);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_210);
	timer_2_cmp_210.stop();
	taco::util::TimeResults res_2_cmp_210 = timer_2_cmp_210.getResult();
	cout << " | 2_cmp_210 ";
	cout << " | "<< res_2_cmp_210 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_3_cmp_10;
	timer_3_cmp_10.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_10);
	timer_3_cmp_10.stop();
	taco::util::TimeResults res_3_cmp_10 = timer_3_cmp_10.getResult();
	cout << " | 3_cmp_10 ";
	cout << " | "<< res_3_cmp_10 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (3, 4, 2, 1, 0)
int transpose_coo_34210_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (3, 4, 2, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 0, 1, 2, 3)
	taco::util::Timer timer_0_cmp_40123;
	timer_0_cmp_40123.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40123);
	timer_0_cmp_40123.stop();
	taco::util::TimeResults res_0_cmp_40123 = timer_0_cmp_40123.getResult();
	cout << " | 0_cmp_40123 ";
	cout << " | "<< res_0_cmp_40123 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_0123;
	timer_1_cmp_0123.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0123);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0123);
	timer_1_cmp_0123.stop();
	taco::util::TimeResults res_1_cmp_0123 = timer_1_cmp_0123.getResult();
	cout << " | 1_cmp_0123 ";
	cout << " | "<< res_1_cmp_0123 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_123;
	timer_2_cmp_123.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_123);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_123);
	timer_2_cmp_123.stop();
	taco::util::TimeResults res_2_cmp_123 = timer_2_cmp_123.getResult();
	cout << " | 2_cmp_123 ";
	cout << " | "<< res_2_cmp_123 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_23;
	timer_3_cmp_23.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_23);
	timer_3_cmp_23.stop();
	taco::util::TimeResults res_3_cmp_23 = timer_3_cmp_23.getResult();
	cout << " | 3_cmp_23 ";
	cout << " | "<< res_3_cmp_23 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 2, 3)
int transpose_coo_40123_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 0, 1, 3, 2)
	taco::util::Timer timer_0_cmp_40132;
	timer_0_cmp_40132.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40132);
	timer_0_cmp_40132.stop();
	taco::util::TimeResults res_0_cmp_40132 = timer_0_cmp_40132.getResult();
	cout << " | 0_cmp_40132 ";
	cout << " | "<< res_0_cmp_40132 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_0132;
	timer_1_cmp_0132.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0132);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0132);
	timer_1_cmp_0132.stop();
	taco::util::TimeResults res_1_cmp_0132 = timer_1_cmp_0132.getResult();
	cout << " | 1_cmp_0132 ";
	cout << " | "<< res_1_cmp_0132 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_132;
	timer_2_cmp_132.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_132);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_132);
	timer_2_cmp_132.stop();
	taco::util::TimeResults res_2_cmp_132 = timer_2_cmp_132.getResult();
	cout << " | 2_cmp_132 ";
	cout << " | "<< res_2_cmp_132 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_32;
	timer_3_cmp_32.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_32);
	timer_3_cmp_32.stop();
	taco::util::TimeResults res_3_cmp_32 = timer_3_cmp_32.getResult();
	cout << " | 3_cmp_32 ";
	cout << " | "<< res_3_cmp_32 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0, 1]
	taco::util::Timer timer_3401;
	timer_3401.start();
	// Create buckets and quotient
	int *bucket_3401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3401 = (int *)malloc(c_size*sizeof(int));
	int current_3401 = 0;
	bucket_3401[0] = 0;
	quotient_3401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		bucket_3401[i] = current_3401;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3401[i];
		B3_count[idx3]--;
	}
	free(bucket_3401);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3401[perm[i]]] = C_coords_scratch[i];
		quotient_3401[perm[i]] ++;
	}
	free(quotient_3401);
	timer_3401.stop();
	taco::util::TimeResults res_3401 = timer_3401.getResult();
	cout << " , (3, [4, 0, 1]) ";
	cout << " , "<< res_3401 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 1, 3, 2)
int transpose_coo_40132_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 1, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0, 1]
	taco::util::Timer timer_3401;
	timer_3401.start();
	// Create buckets and quotient
	int *bucket_3401 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3401 = (int *)malloc(c_size*sizeof(int));
	int current_3401 = 0;
	bucket_3401[0] = 0;
	quotient_3401[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3401++;
			quotient_3401[current_3401] = i;
		}
		bucket_3401[i] = current_3401;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3401[i];
		B3_count[idx3]--;
	}
	free(bucket_3401);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3401[perm[i]]] = C_coords_scratch[i];
		quotient_3401[perm[i]] ++;
	}
	free(quotient_3401);
	timer_3401.stop();
	taco::util::TimeResults res_3401 = timer_3401.getResult();
	cout << " , (3, [4, 0, 1]) ";
	cout << " , "<< res_3401 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 0, 2, 1, 3)
	taco::util::Timer timer_0_cmp_40213;
	timer_0_cmp_40213.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40213);
	timer_0_cmp_40213.stop();
	taco::util::TimeResults res_0_cmp_40213 = timer_0_cmp_40213.getResult();
	cout << " | 0_cmp_40213 ";
	cout << " | "<< res_0_cmp_40213 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_0213;
	timer_1_cmp_0213.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0213);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0213);
	timer_1_cmp_0213.stop();
	taco::util::TimeResults res_1_cmp_0213 = timer_1_cmp_0213.getResult();
	cout << " | 1_cmp_0213 ";
	cout << " | "<< res_1_cmp_0213 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_213;
	timer_2_cmp_213.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_213);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_213);
	timer_2_cmp_213.stop();
	taco::util::TimeResults res_2_cmp_213 = timer_2_cmp_213.getResult();
	cout << " | 2_cmp_213 ";
	cout << " | "<< res_2_cmp_213 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	taco::util::Timer timer_3_cmp_13;
	timer_3_cmp_13.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_13);
	timer_3_cmp_13.stop();
	taco::util::TimeResults res_3_cmp_13 = timer_3_cmp_13.getResult();
	cout << " | 3_cmp_13 ";
	cout << " | "<< res_3_cmp_13 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 1, 3)
int transpose_coo_40213_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 0, 2, 3, 1)
	taco::util::Timer timer_0_cmp_40231;
	timer_0_cmp_40231.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40231);
	timer_0_cmp_40231.stop();
	taco::util::TimeResults res_0_cmp_40231 = timer_0_cmp_40231.getResult();
	cout << " | 0_cmp_40231 ";
	cout << " | "<< res_0_cmp_40231 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_0231;
	timer_1_cmp_0231.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0231);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0231);
	timer_1_cmp_0231.stop();
	taco::util::TimeResults res_1_cmp_0231 = timer_1_cmp_0231.getResult();
	cout << " | 1_cmp_0231 ";
	cout << " | "<< res_1_cmp_0231 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_231;
	timer_2_cmp_231.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_231);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_231);
	timer_2_cmp_231.stop();
	taco::util::TimeResults res_2_cmp_231 = timer_2_cmp_231.getResult();
	cout << " | 2_cmp_231 ";
	cout << " | "<< res_2_cmp_231 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	taco::util::Timer timer_3_cmp_31;
	timer_3_cmp_31.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_31);
	timer_3_cmp_31.stop();
	taco::util::TimeResults res_3_cmp_31 = timer_3_cmp_31.getResult();
	cout << " | 3_cmp_31 ";
	cout << " | "<< res_3_cmp_31 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 2, 3, 1)
int transpose_coo_40231_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 2, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 0, 3, 1, 2)
	taco::util::Timer timer_0_cmp_40312;
	timer_0_cmp_40312.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40312);
	timer_0_cmp_40312.stop();
	taco::util::TimeResults res_0_cmp_40312 = timer_0_cmp_40312.getResult();
	cout << " | 0_cmp_40312 ";
	cout << " | "<< res_0_cmp_40312 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_0312;
	timer_1_cmp_0312.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0312);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0312);
	timer_1_cmp_0312.stop();
	taco::util::TimeResults res_1_cmp_0312 = timer_1_cmp_0312.getResult();
	cout << " | 1_cmp_0312 ";
	cout << " | "<< res_1_cmp_0312 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_312;
	timer_2_cmp_312.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_312);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_312);
	timer_2_cmp_312.stop();
	taco::util::TimeResults res_2_cmp_312 = timer_2_cmp_312.getResult();
	cout << " | 2_cmp_312 ";
	cout << " | "<< res_2_cmp_312 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	taco::util::Timer timer_3_cmp_12;
	timer_3_cmp_12.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_12);
	timer_3_cmp_12.stop();
	taco::util::TimeResults res_3_cmp_12 = timer_3_cmp_12.getResult();
	cout << " | 3_cmp_12 ";
	cout << " | "<< res_3_cmp_12 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 1, 2)
int transpose_coo_40312_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 0, 3, 2, 1)
	taco::util::Timer timer_0_cmp_40321;
	timer_0_cmp_40321.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_40321);
	timer_0_cmp_40321.stop();
	taco::util::TimeResults res_0_cmp_40321 = timer_0_cmp_40321.getResult();
	cout << " | 0_cmp_40321 ";
	cout << " | "<< res_0_cmp_40321 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_0321;
	timer_1_cmp_0321.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0321);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0321);
	timer_1_cmp_0321.stop();
	taco::util::TimeResults res_1_cmp_0321 = timer_1_cmp_0321.getResult();
	cout << " | 1_cmp_0321 ";
	cout << " | "<< res_1_cmp_0321 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_321;
	timer_2_cmp_321.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_321);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_321);
	timer_2_cmp_321.stop();
	taco::util::TimeResults res_2_cmp_321 = timer_2_cmp_321.getResult();
	cout << " | 2_cmp_321 ";
	cout << " | "<< res_2_cmp_321 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	taco::util::Timer timer_3_cmp_21;
	timer_3_cmp_21.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_21);
	timer_3_cmp_21.stop();
	taco::util::TimeResults res_3_cmp_21 = timer_3_cmp_21.getResult();
	cout << " | 3_cmp_21 ";
	cout << " | "<< res_3_cmp_21 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 0, 3, 2, 1)
int transpose_coo_40321_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 0, 3, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_240;
	timer_240.start();
	// Create buckets and quotient
	int *bucket_240 = (int *)malloc(c_size*sizeof(int));
	int *quotient_240 = (int *)malloc(c_size*sizeof(int));
	int current_240 = 0;
	bucket_240[0] = 0;
	quotient_240[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_240++;
			quotient_240[current_240] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_240++;
			quotient_240[current_240] = i;
		}
		bucket_240[i] = current_240;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_240[i];
		B2_count[idx2]--;
	}
	free(bucket_240);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_240[perm[i]]] = C_coords_scratch[i];
		quotient_240[perm[i]] ++;
	}
	free(quotient_240);
	timer_240.stop();
	taco::util::TimeResults res_240 = timer_240.getResult();
	cout << " , (2, [4, 0]) ";
	cout << " , "<< res_240 ;
	// Fix and sort on [4, 0]
	taco::util::Timer timer_340;
	timer_340.start();
	// Create buckets and quotient
	int *bucket_340 = (int *)malloc(c_size*sizeof(int));
	int *quotient_340 = (int *)malloc(c_size*sizeof(int));
	int current_340 = 0;
	bucket_340[0] = 0;
	quotient_340[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_340++;
			quotient_340[current_340] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_340++;
			quotient_340[current_340] = i;
		}
		bucket_340[i] = current_340;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_340[i];
		B3_count[idx3]--;
	}
	free(bucket_340);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_340[perm[i]]] = C_coords_scratch[i];
		quotient_340[perm[i]] ++;
	}
	free(quotient_340);
	timer_340.stop();
	taco::util::TimeResults res_340 = timer_340.getResult();
	cout << " , (3, [4, 0]) ";
	cout << " , "<< res_340 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 1, 0, 2, 3)
	taco::util::Timer timer_0_cmp_41023;
	timer_0_cmp_41023.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41023);
	timer_0_cmp_41023.stop();
	taco::util::TimeResults res_0_cmp_41023 = timer_0_cmp_41023.getResult();
	cout << " | 0_cmp_41023 ";
	cout << " | "<< res_0_cmp_41023 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_1023;
	timer_1_cmp_1023.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1023);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1023);
	timer_1_cmp_1023.stop();
	taco::util::TimeResults res_1_cmp_1023 = timer_1_cmp_1023.getResult();
	cout << " | 1_cmp_1023 ";
	cout << " | "<< res_1_cmp_1023 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_023;
	timer_2_cmp_023.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_023);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_023);
	timer_2_cmp_023.stop();
	taco::util::TimeResults res_2_cmp_023 = timer_2_cmp_023.getResult();
	cout << " | 2_cmp_023 ";
	cout << " | "<< res_2_cmp_023 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_23;
	timer_3_cmp_23.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_23);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_23);
	timer_3_cmp_23.stop();
	taco::util::TimeResults res_3_cmp_23 = timer_3_cmp_23.getResult();
	cout << " | 3_cmp_23 ";
	cout << " | "<< res_3_cmp_23 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 2, 3)
int transpose_coo_41023_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 2, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 1, 0, 3, 2)
	taco::util::Timer timer_0_cmp_41032;
	timer_0_cmp_41032.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41032);
	timer_0_cmp_41032.stop();
	taco::util::TimeResults res_0_cmp_41032 = timer_0_cmp_41032.getResult();
	cout << " | 0_cmp_41032 ";
	cout << " | "<< res_0_cmp_41032 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_1032;
	timer_1_cmp_1032.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1032);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1032);
	timer_1_cmp_1032.stop();
	taco::util::TimeResults res_1_cmp_1032 = timer_1_cmp_1032.getResult();
	cout << " | 1_cmp_1032 ";
	cout << " | "<< res_1_cmp_1032 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_032;
	timer_2_cmp_032.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_032);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_032);
	timer_2_cmp_032.stop();
	taco::util::TimeResults res_2_cmp_032 = timer_2_cmp_032.getResult();
	cout << " | 2_cmp_032 ";
	cout << " | "<< res_2_cmp_032 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_32;
	timer_3_cmp_32.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_32);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_32);
	timer_3_cmp_32.stop();
	taco::util::TimeResults res_3_cmp_32 = timer_3_cmp_32.getResult();
	cout << " | 3_cmp_32 ";
	cout << " | "<< res_3_cmp_32 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 1, 0]
	taco::util::Timer timer_3410;
	timer_3410.start();
	// Create buckets and quotient
	int *bucket_3410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3410 = (int *)malloc(c_size*sizeof(int));
	int current_3410 = 0;
	bucket_3410[0] = 0;
	quotient_3410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		bucket_3410[i] = current_3410;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3410[i];
		B3_count[idx3]--;
	}
	free(bucket_3410);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3410[perm[i]]] = C_coords_scratch[i];
		quotient_3410[perm[i]] ++;
	}
	free(quotient_3410);
	timer_3410.stop();
	taco::util::TimeResults res_3410 = timer_3410.getResult();
	cout << " , (3, [4, 1, 0]) ";
	cout << " , "<< res_3410 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 0, 3, 2)
int transpose_coo_41032_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 0, 3, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 1, 0]
	taco::util::Timer timer_3410;
	timer_3410.start();
	// Create buckets and quotient
	int *bucket_3410 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3410 = (int *)malloc(c_size*sizeof(int));
	int current_3410 = 0;
	bucket_3410[0] = 0;
	quotient_3410[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3410++;
			quotient_3410[current_3410] = i;
		}
		bucket_3410[i] = current_3410;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3410[i];
		B3_count[idx3]--;
	}
	free(bucket_3410);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3410[perm[i]]] = C_coords_scratch[i];
		quotient_3410[perm[i]] ++;
	}
	free(quotient_3410);
	timer_3410.stop();
	taco::util::TimeResults res_3410 = timer_3410.getResult();
	cout << " , (3, [4, 1, 0]) ";
	cout << " , "<< res_3410 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 1, 2, 0, 3)
	taco::util::Timer timer_0_cmp_41203;
	timer_0_cmp_41203.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41203);
	timer_0_cmp_41203.stop();
	taco::util::TimeResults res_0_cmp_41203 = timer_0_cmp_41203.getResult();
	cout << " | 0_cmp_41203 ";
	cout << " | "<< res_0_cmp_41203 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_1203;
	timer_1_cmp_1203.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1203);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1203);
	timer_1_cmp_1203.stop();
	taco::util::TimeResults res_1_cmp_1203 = timer_1_cmp_1203.getResult();
	cout << " | 1_cmp_1203 ";
	cout << " | "<< res_1_cmp_1203 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_203;
	timer_2_cmp_203.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_203);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_203);
	timer_2_cmp_203.stop();
	taco::util::TimeResults res_2_cmp_203 = timer_2_cmp_203.getResult();
	cout << " | 2_cmp_203 ";
	cout << " | "<< res_2_cmp_203 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_03;
	timer_3_cmp_03.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_03);
	timer_3_cmp_03.stop();
	taco::util::TimeResults res_3_cmp_03 = timer_3_cmp_03.getResult();
	cout << " | 3_cmp_03 ";
	cout << " | "<< res_3_cmp_03 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 0, 3)
int transpose_coo_41203_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 1, 2, 3, 0)
	taco::util::Timer timer_0_cmp_41230;
	timer_0_cmp_41230.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41230);
	timer_0_cmp_41230.stop();
	taco::util::TimeResults res_0_cmp_41230 = timer_0_cmp_41230.getResult();
	cout << " | 0_cmp_41230 ";
	cout << " | "<< res_0_cmp_41230 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_1230;
	timer_1_cmp_1230.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1230);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1230);
	timer_1_cmp_1230.stop();
	taco::util::TimeResults res_1_cmp_1230 = timer_1_cmp_1230.getResult();
	cout << " | 1_cmp_1230 ";
	cout << " | "<< res_1_cmp_1230 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_230;
	timer_2_cmp_230.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_230);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_230);
	timer_2_cmp_230.stop();
	taco::util::TimeResults res_2_cmp_230 = timer_2_cmp_230.getResult();
	cout << " | 2_cmp_230 ";
	cout << " | "<< res_2_cmp_230 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_30;
	timer_3_cmp_30.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_30);
	timer_3_cmp_30.stop();
	taco::util::TimeResults res_3_cmp_30 = timer_3_cmp_30.getResult();
	cout << " | 3_cmp_30 ";
	cout << " | "<< res_3_cmp_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 2, 3, 0)
int transpose_coo_41230_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 2, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 1, 3, 0, 2)
	taco::util::Timer timer_0_cmp_41302;
	timer_0_cmp_41302.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41302);
	timer_0_cmp_41302.stop();
	taco::util::TimeResults res_0_cmp_41302 = timer_0_cmp_41302.getResult();
	cout << " | 0_cmp_41302 ";
	cout << " | "<< res_0_cmp_41302 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_1302;
	timer_1_cmp_1302.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1302);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1302);
	timer_1_cmp_1302.stop();
	taco::util::TimeResults res_1_cmp_1302 = timer_1_cmp_1302.getResult();
	cout << " | 1_cmp_1302 ";
	cout << " | "<< res_1_cmp_1302 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_302;
	timer_2_cmp_302.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_302);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_302);
	timer_2_cmp_302.stop();
	taco::util::TimeResults res_2_cmp_302 = timer_2_cmp_302.getResult();
	cout << " | 2_cmp_302 ";
	cout << " | "<< res_2_cmp_302 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_02;
	timer_3_cmp_02.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_02);
	timer_3_cmp_02.stop();
	taco::util::TimeResults res_3_cmp_02 = timer_3_cmp_02.getResult();
	cout << " | 3_cmp_02 ";
	cout << " | "<< res_3_cmp_02 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 0, 2)
int transpose_coo_41302_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 1, 3, 2, 0)
	taco::util::Timer timer_0_cmp_41320;
	timer_0_cmp_41320.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_41320);
	timer_0_cmp_41320.stop();
	taco::util::TimeResults res_0_cmp_41320 = timer_0_cmp_41320.getResult();
	cout << " | 0_cmp_41320 ";
	cout << " | "<< res_0_cmp_41320 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_1320;
	timer_1_cmp_1320.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1320);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1320);
	timer_1_cmp_1320.stop();
	taco::util::TimeResults res_1_cmp_1320 = timer_1_cmp_1320.getResult();
	cout << " | 1_cmp_1320 ";
	cout << " | "<< res_1_cmp_1320 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_320;
	timer_2_cmp_320.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_320);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_320);
	timer_2_cmp_320.stop();
	taco::util::TimeResults res_2_cmp_320 = timer_2_cmp_320.getResult();
	cout << " | 2_cmp_320 ";
	cout << " | "<< res_2_cmp_320 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_20;
	timer_3_cmp_20.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_20);
	timer_3_cmp_20.stop();
	taco::util::TimeResults res_3_cmp_20 = timer_3_cmp_20.getResult();
	cout << " | 3_cmp_20 ";
	cout << " | "<< res_3_cmp_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 1, 3, 2, 0)
int transpose_coo_41320_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 1, 3, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 2, 0, 1, 3)
	taco::util::Timer timer_0_cmp_42013;
	timer_0_cmp_42013.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42013);
	timer_0_cmp_42013.stop();
	taco::util::TimeResults res_0_cmp_42013 = timer_0_cmp_42013.getResult();
	cout << " | 0_cmp_42013 ";
	cout << " | "<< res_0_cmp_42013 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_2013;
	timer_1_cmp_2013.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2013);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2013);
	timer_1_cmp_2013.stop();
	taco::util::TimeResults res_1_cmp_2013 = timer_1_cmp_2013.getResult();
	cout << " | 1_cmp_2013 ";
	cout << " | "<< res_1_cmp_2013 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_013;
	timer_2_cmp_013.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_013);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_013);
	timer_2_cmp_013.stop();
	taco::util::TimeResults res_2_cmp_013 = timer_2_cmp_013.getResult();
	cout << " | 2_cmp_013 ";
	cout << " | "<< res_2_cmp_013 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_13;
	timer_3_cmp_13.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_13);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_13);
	timer_3_cmp_13.stop();
	taco::util::TimeResults res_3_cmp_13 = timer_3_cmp_13.getResult();
	cout << " | 3_cmp_13 ";
	cout << " | "<< res_3_cmp_13 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 1, 3)
int transpose_coo_42013_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 1, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 2, 0, 3, 1)
	taco::util::Timer timer_0_cmp_42031;
	timer_0_cmp_42031.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42031);
	timer_0_cmp_42031.stop();
	taco::util::TimeResults res_0_cmp_42031 = timer_0_cmp_42031.getResult();
	cout << " | 0_cmp_42031 ";
	cout << " | "<< res_0_cmp_42031 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_2031;
	timer_1_cmp_2031.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2031);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2031);
	timer_1_cmp_2031.stop();
	taco::util::TimeResults res_1_cmp_2031 = timer_1_cmp_2031.getResult();
	cout << " | 1_cmp_2031 ";
	cout << " | "<< res_1_cmp_2031 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_031;
	timer_2_cmp_031.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_031);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_031);
	timer_2_cmp_031.stop();
	taco::util::TimeResults res_2_cmp_031 = timer_2_cmp_031.getResult();
	cout << " | 2_cmp_031 ";
	cout << " | "<< res_2_cmp_031 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_31;
	timer_3_cmp_31.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_31);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_31);
	timer_3_cmp_31.stop();
	taco::util::TimeResults res_3_cmp_31 = timer_3_cmp_31.getResult();
	cout << " | 3_cmp_31 ";
	cout << " | "<< res_3_cmp_31 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 2, 0]
	taco::util::Timer timer_3420;
	timer_3420.start();
	// Create buckets and quotient
	int *bucket_3420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3420 = (int *)malloc(c_size*sizeof(int));
	int current_3420 = 0;
	bucket_3420[0] = 0;
	quotient_3420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		bucket_3420[i] = current_3420;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3420[i];
		B3_count[idx3]--;
	}
	free(bucket_3420);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3420[perm[i]]] = C_coords_scratch[i];
		quotient_3420[perm[i]] ++;
	}
	free(quotient_3420);
	timer_3420.stop();
	taco::util::TimeResults res_3420 = timer_3420.getResult();
	cout << " , (3, [4, 2, 0]) ";
	cout << " , "<< res_3420 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 0, 3, 1)
int transpose_coo_42031_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 0, 3, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 2, 0]
	taco::util::Timer timer_3420;
	timer_3420.start();
	// Create buckets and quotient
	int *bucket_3420 = (int *)malloc(c_size*sizeof(int));
	int *quotient_3420 = (int *)malloc(c_size*sizeof(int));
	int current_3420 = 0;
	bucket_3420[0] = 0;
	quotient_3420[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_3420++;
			quotient_3420[current_3420] = i;
		}
		bucket_3420[i] = current_3420;
	}

	// Histogram sort on mode 3 into the permutation array
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_3420[i];
		B3_count[idx3]--;
	}
	free(bucket_3420);
	free(B3_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_3420[perm[i]]] = C_coords_scratch[i];
		quotient_3420[perm[i]] ++;
	}
	free(quotient_3420);
	timer_3420.stop();
	taco::util::TimeResults res_3420 = timer_3420.getResult();
	cout << " , (3, [4, 2, 0]) ";
	cout << " , "<< res_3420 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 2, 1, 0, 3)
	taco::util::Timer timer_0_cmp_42103;
	timer_0_cmp_42103.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42103);
	timer_0_cmp_42103.stop();
	taco::util::TimeResults res_0_cmp_42103 = timer_0_cmp_42103.getResult();
	cout << " | 0_cmp_42103 ";
	cout << " | "<< res_0_cmp_42103 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_2103;
	timer_1_cmp_2103.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2103);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2103);
	timer_1_cmp_2103.stop();
	taco::util::TimeResults res_1_cmp_2103 = timer_1_cmp_2103.getResult();
	cout << " | 1_cmp_2103 ";
	cout << " | "<< res_1_cmp_2103 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_103;
	timer_2_cmp_103.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_103);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_103);
	timer_2_cmp_103.stop();
	taco::util::TimeResults res_2_cmp_103 = timer_2_cmp_103.getResult();
	cout << " | 2_cmp_103 ";
	cout << " | "<< res_2_cmp_103 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_03;
	timer_3_cmp_03.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_03);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_03);
	timer_3_cmp_03.stop();
	taco::util::TimeResults res_3_cmp_03 = timer_3_cmp_03.getResult();
	cout << " | 3_cmp_03 ";
	cout << " | "<< res_3_cmp_03 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_3;
	timer_4_cmp_3.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3);
	timer_4_cmp_3.stop();
	taco::util::TimeResults res_4_cmp_3 = timer_4_cmp_3.getResult();
	cout << " | 4_cmp_3 ";
	cout << " | "<< res_4_cmp_3 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 0, 3)
int transpose_coo_42103_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 0, 3)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 2, 1, 3, 0)
	taco::util::Timer timer_0_cmp_42130;
	timer_0_cmp_42130.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42130);
	timer_0_cmp_42130.stop();
	taco::util::TimeResults res_0_cmp_42130 = timer_0_cmp_42130.getResult();
	cout << " | 0_cmp_42130 ";
	cout << " | "<< res_0_cmp_42130 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_2130;
	timer_1_cmp_2130.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2130);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2130);
	timer_1_cmp_2130.stop();
	taco::util::TimeResults res_1_cmp_2130 = timer_1_cmp_2130.getResult();
	cout << " | 1_cmp_2130 ";
	cout << " | "<< res_1_cmp_2130 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_130;
	timer_2_cmp_130.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_130);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_130);
	timer_2_cmp_130.stop();
	taco::util::TimeResults res_2_cmp_130 = timer_2_cmp_130.getResult();
	cout << " | 2_cmp_130 ";
	cout << " | "<< res_2_cmp_130 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_30;
	timer_3_cmp_30.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_30);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_30);
	timer_3_cmp_30.stop();
	taco::util::TimeResults res_3_cmp_30 = timer_3_cmp_30.getResult();
	cout << " | 3_cmp_30 ";
	cout << " | "<< res_3_cmp_30 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 1, 3, 0)
int transpose_coo_42130_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 1, 3, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 2, 3, 0, 1)
	taco::util::Timer timer_0_cmp_42301;
	timer_0_cmp_42301.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42301);
	timer_0_cmp_42301.stop();
	taco::util::TimeResults res_0_cmp_42301 = timer_0_cmp_42301.getResult();
	cout << " | 0_cmp_42301 ";
	cout << " | "<< res_0_cmp_42301 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_2301;
	timer_1_cmp_2301.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2301);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2301);
	timer_1_cmp_2301.stop();
	taco::util::TimeResults res_1_cmp_2301 = timer_1_cmp_2301.getResult();
	cout << " | 1_cmp_2301 ";
	cout << " | "<< res_1_cmp_2301 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_301;
	timer_2_cmp_301.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_301);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_301);
	timer_2_cmp_301.stop();
	taco::util::TimeResults res_2_cmp_301 = timer_2_cmp_301.getResult();
	cout << " | 2_cmp_301 ";
	cout << " | "<< res_2_cmp_301 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_01;
	timer_3_cmp_01.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_01);
	timer_3_cmp_01.stop();
	taco::util::TimeResults res_3_cmp_01 = timer_3_cmp_01.getResult();
	cout << " | 3_cmp_01 ";
	cout << " | "<< res_3_cmp_01 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 0, 1)
int transpose_coo_42301_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 2, 3, 1, 0)
	taco::util::Timer timer_0_cmp_42310;
	timer_0_cmp_42310.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_42310);
	timer_0_cmp_42310.stop();
	taco::util::TimeResults res_0_cmp_42310 = timer_0_cmp_42310.getResult();
	cout << " | 0_cmp_42310 ";
	cout << " | "<< res_0_cmp_42310 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_2310;
	timer_1_cmp_2310.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2310);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2310);
	timer_1_cmp_2310.stop();
	taco::util::TimeResults res_1_cmp_2310 = timer_1_cmp_2310.getResult();
	cout << " | 1_cmp_2310 ";
	cout << " | "<< res_1_cmp_2310 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_310;
	timer_2_cmp_310.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_310);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_310);
	timer_2_cmp_310.stop();
	taco::util::TimeResults res_2_cmp_310 = timer_2_cmp_310.getResult();
	cout << " | 2_cmp_310 ";
	cout << " | "<< res_2_cmp_310 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_10;
	timer_3_cmp_10.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_10);
	timer_3_cmp_10.stop();
	taco::util::TimeResults res_3_cmp_10 = timer_3_cmp_10.getResult();
	cout << " | 3_cmp_10 ";
	cout << " | "<< res_3_cmp_10 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 2, 3, 1, 0)
int transpose_coo_42310_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 2, 3, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 3, 0, 1, 2)
	taco::util::Timer timer_0_cmp_43012;
	timer_0_cmp_43012.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43012);
	timer_0_cmp_43012.stop();
	taco::util::TimeResults res_0_cmp_43012 = timer_0_cmp_43012.getResult();
	cout << " | 0_cmp_43012 ";
	cout << " | "<< res_0_cmp_43012 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_3012;
	timer_1_cmp_3012.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3012);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3012);
	timer_1_cmp_3012.stop();
	taco::util::TimeResults res_1_cmp_3012 = timer_1_cmp_3012.getResult();
	cout << " | 1_cmp_3012 ";
	cout << " | "<< res_1_cmp_3012 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_012;
	timer_2_cmp_012.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_012);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_012);
	timer_2_cmp_012.stop();
	taco::util::TimeResults res_2_cmp_012 = timer_2_cmp_012.getResult();
	cout << " | 2_cmp_012 ";
	cout << " | "<< res_2_cmp_012 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_12;
	timer_3_cmp_12.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_12);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_12);
	timer_3_cmp_12.stop();
	taco::util::TimeResults res_3_cmp_12 = timer_3_cmp_12.getResult();
	cout << " | 3_cmp_12 ";
	cout << " | "<< res_3_cmp_12 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 1, 2)
int transpose_coo_43012_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 1, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 3, 0, 2, 1)
	taco::util::Timer timer_0_cmp_43021;
	timer_0_cmp_43021.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43021);
	timer_0_cmp_43021.stop();
	taco::util::TimeResults res_0_cmp_43021 = timer_0_cmp_43021.getResult();
	cout << " | 0_cmp_43021 ";
	cout << " | "<< res_0_cmp_43021 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_3021;
	timer_1_cmp_3021.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3021);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3021);
	timer_1_cmp_3021.stop();
	taco::util::TimeResults res_1_cmp_3021 = timer_1_cmp_3021.getResult();
	cout << " | 1_cmp_3021 ";
	cout << " | "<< res_1_cmp_3021 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_021;
	timer_2_cmp_021.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_021);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_021);
	timer_2_cmp_021.stop();
	taco::util::TimeResults res_2_cmp_021 = timer_2_cmp_021.getResult();
	cout << " | 2_cmp_021 ";
	cout << " | "<< res_2_cmp_021 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_21;
	timer_3_cmp_21.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_21);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_21);
	timer_3_cmp_21.stop();
	taco::util::TimeResults res_3_cmp_21 = timer_3_cmp_21.getResult();
	cout << " | 3_cmp_21 ";
	cout << " | "<< res_3_cmp_21 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 3, 0]
	taco::util::Timer timer_2430;
	timer_2430.start();
	// Create buckets and quotient
	int *bucket_2430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2430 = (int *)malloc(c_size*sizeof(int));
	int current_2430 = 0;
	bucket_2430[0] = 0;
	quotient_2430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		bucket_2430[i] = current_2430;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2430[i];
		B2_count[idx2]--;
	}
	free(bucket_2430);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2430[perm[i]]] = C_coords_scratch[i];
		quotient_2430[perm[i]] ++;
	}
	free(quotient_2430);
	timer_2430.stop();
	taco::util::TimeResults res_2430 = timer_2430.getResult();
	cout << " , (2, [4, 3, 0]) ";
	cout << " , "<< res_2430 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 0, 2, 1)
int transpose_coo_43021_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 0, 2, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Fix and sort on [4, 3, 0]
	taco::util::Timer timer_2430;
	timer_2430.start();
	// Create buckets and quotient
	int *bucket_2430 = (int *)malloc(c_size*sizeof(int));
	int *quotient_2430 = (int *)malloc(c_size*sizeof(int));
	int current_2430 = 0;
	bucket_2430[0] = 0;
	quotient_2430[0] = 0;
	for(int i = 1; i < c_size; i ++)
	{
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			current_2430++;
			quotient_2430[current_2430] = i;
		}
		bucket_2430[i] = current_2430;
	}

	// Histogram sort on mode 2 into the permutation array
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		perm[idx] = bucket_2430[i];
		B2_count[idx2]--;
	}
	free(bucket_2430);
	free(B2_count);

	// Move the items back to the buckets.
	for (int i = 0; i < c_size; i ++) {
		C_coords[quotient_2430[perm[i]]] = C_coords_scratch[i];
		quotient_2430[perm[i]] ++;
	}
	free(quotient_2430);
	timer_2430.stop();
	taco::util::TimeResults res_2430 = timer_2430.getResult();
	cout << " , (2, [4, 3, 0]) ";
	cout << " , "<< res_2430 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 3, 1, 0, 2)
	taco::util::Timer timer_0_cmp_43102;
	timer_0_cmp_43102.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43102);
	timer_0_cmp_43102.stop();
	taco::util::TimeResults res_0_cmp_43102 = timer_0_cmp_43102.getResult();
	cout << " | 0_cmp_43102 ";
	cout << " | "<< res_0_cmp_43102 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_3102;
	timer_1_cmp_3102.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3102);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3102);
	timer_1_cmp_3102.stop();
	taco::util::TimeResults res_1_cmp_3102 = timer_1_cmp_3102.getResult();
	cout << " | 1_cmp_3102 ";
	cout << " | "<< res_1_cmp_3102 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_102;
	timer_2_cmp_102.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_102);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_102);
	timer_2_cmp_102.stop();
	taco::util::TimeResults res_2_cmp_102 = timer_2_cmp_102.getResult();
	cout << " | 2_cmp_102 ";
	cout << " | "<< res_2_cmp_102 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_02;
	timer_3_cmp_02.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_02);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_02);
	timer_3_cmp_02.stop();
	taco::util::TimeResults res_3_cmp_02 = timer_3_cmp_02.getResult();
	cout << " | 3_cmp_02 ";
	cout << " | "<< res_3_cmp_02 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_2;
	timer_4_cmp_2.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_2);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_2);
	timer_4_cmp_2.stop();
	taco::util::TimeResults res_4_cmp_2 = timer_4_cmp_2.getResult();
	cout << " | 4_cmp_2 ";
	cout << " | "<< res_4_cmp_2 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 0, 2)
int transpose_coo_43102_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 0, 2)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 3, 1, 2, 0)
	taco::util::Timer timer_0_cmp_43120;
	timer_0_cmp_43120.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43120);
	timer_0_cmp_43120.stop();
	taco::util::TimeResults res_0_cmp_43120 = timer_0_cmp_43120.getResult();
	cout << " | 0_cmp_43120 ";
	cout << " | "<< res_0_cmp_43120 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_3120;
	timer_1_cmp_3120.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3120);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3120);
	timer_1_cmp_3120.stop();
	taco::util::TimeResults res_1_cmp_3120 = timer_1_cmp_3120.getResult();
	cout << " | 1_cmp_3120 ";
	cout << " | "<< res_1_cmp_3120 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_120;
	timer_2_cmp_120.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_120);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_120);
	timer_2_cmp_120.stop();
	taco::util::TimeResults res_2_cmp_120 = timer_2_cmp_120.getResult();
	cout << " | 2_cmp_120 ";
	cout << " | "<< res_2_cmp_120 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_20;
	timer_3_cmp_20.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_20);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_20);
	timer_3_cmp_20.stop();
	taco::util::TimeResults res_3_cmp_20 = timer_3_cmp_20.getResult();
	cout << " | 3_cmp_20 ";
	cout << " | "<< res_3_cmp_20 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 1, 2, 0)
int transpose_coo_43120_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 1, 2, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 3, 2, 0, 1)
	taco::util::Timer timer_0_cmp_43201;
	timer_0_cmp_43201.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43201);
	timer_0_cmp_43201.stop();
	taco::util::TimeResults res_0_cmp_43201 = timer_0_cmp_43201.getResult();
	cout << " | 0_cmp_43201 ";
	cout << " | "<< res_0_cmp_43201 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_3201;
	timer_1_cmp_3201.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3201);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3201);
	timer_1_cmp_3201.stop();
	taco::util::TimeResults res_1_cmp_3201 = timer_1_cmp_3201.getResult();
	cout << " | 1_cmp_3201 ";
	cout << " | "<< res_1_cmp_3201 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_201;
	timer_2_cmp_201.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_201);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_201);
	timer_2_cmp_201.stop();
	taco::util::TimeResults res_2_cmp_201 = timer_2_cmp_201.getResult();
	cout << " | 2_cmp_201 ";
	cout << " | "<< res_2_cmp_201 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_01;
	timer_3_cmp_01.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_01);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_01);
	timer_3_cmp_01.stop();
	taco::util::TimeResults res_3_cmp_01 = timer_3_cmp_01.getResult();
	cout << " | 3_cmp_01 ";
	cout << " | "<< res_3_cmp_01 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_1;
	timer_4_cmp_1.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx0 != C_coords[i - 1].idx0) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_1);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_1);
	timer_4_cmp_1.stop();
	taco::util::TimeResults res_4_cmp_1 = timer_4_cmp_1.getResult();
	cout << " | 4_cmp_1 ";
	cout << " | "<< res_4_cmp_1 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 0, 1)
int transpose_coo_43201_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 0, 1)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k0(struct coo_t *C_coords, int c_size, int order, int *dimensions) {

	// Sort the coordinates to be in (4, 3, 2, 1, 0)
	taco::util::Timer timer_0_cmp_43210;
	timer_0_cmp_43210.start();
	// Use qsort to sort the subtrees
	qsort(C_coords, c_size, sizeof(struct coo_t), cmp_43210);
	timer_0_cmp_43210.stop();
	taco::util::TimeResults res_0_cmp_43210 = timer_0_cmp_43210.getResult();
	cout << " | 0_cmp_43210 ";
	cout << " | "<< res_0_cmp_43210 ;
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k1(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_1_cmp_3210;
	timer_1_cmp_3210.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_3210);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_3210);
	timer_1_cmp_3210.stop();
	taco::util::TimeResults res_1_cmp_3210 = timer_1_cmp_3210.getResult();
	cout << " | 1_cmp_3210 ";
	cout << " | "<< res_1_cmp_3210 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k2(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_2_cmp_210;
	timer_2_cmp_210.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_210);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_210);
	timer_2_cmp_210.stop();
	taco::util::TimeResults res_2_cmp_210 = timer_2_cmp_210.getResult();
	cout << " | 2_cmp_210 ";
	cout << " | "<< res_2_cmp_210 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k3(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_3_cmp_10;
	timer_3_cmp_10.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_10);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_10);
	timer_3_cmp_10.stop();
	taco::util::TimeResults res_3_cmp_10 = timer_3_cmp_10.getResult();
	cout << " | 3_cmp_10 ";
	cout << " | "<< res_3_cmp_10 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k4(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	taco::util::Timer timer_4_cmp_0;
	timer_4_cmp_0.start();
	// Use qsort to sort the subtrees
	int qsort_start = 0;
	for(int i = 1; i < c_size; i ++)
	{
		int qsort_same = 1;
		if(C_coords[i].idx4 != C_coords[i - 1].idx4) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx3 != C_coords[i - 1].idx3) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx2 != C_coords[i - 1].idx2) {
			qsort_same = 0;
		}
		else if(C_coords[i].idx1 != C_coords[i - 1].idx1) {
			qsort_same = 0;
		}
		if (!qsort_same ) { 
			qsort(&C_coords[qsort_start], (i - qsort_start), sizeof(struct coo_t), cmp_0);
			qsort_start = i;
		}
	}
	qsort(&C_coords[qsort_start], (c_size - qsort_start ), sizeof(struct coo_t), cmp_0);
	timer_4_cmp_0.stop();
	taco::util::TimeResults res_4_cmp_0 = timer_4_cmp_0.getResult();
	cout << " | 4_cmp_0 ";
	cout << " | "<< res_4_cmp_0 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}
// transpose permutes the modes of the coordinates to be (4, 3, 2, 1, 0)
int transpose_coo_43210_k5(struct coo_t *C_coords, int c_size, int order, int *dimensions) {
	struct coo_t* C_coords_scratch = (struct coo_t *)malloc(sizeof(struct coo_t) * c_size);
	int* perm = (int *)malloc(sizeof(int) * c_size);

	// Sort the coordinates to be in (4, 3, 2, 1, 0)
	taco::util::Timer timer_1;
	timer_1.start();

	// Histogram sort on mode 1
	int B1_size = dimensions[1];
	int32_t *B1_count = (int32_t *)calloc(B1_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx1 = C_coords[i].idx1;
		B1_count[idx1]++;
	}

	// Prefix sum over B1_count
	for(int idx1 = 1; idx1 < B1_size; idx1 ++)
	{
		B1_count[idx1] += B1_count[idx1 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx1 = C_coords[i].idx1;
		int idx = B1_count[idx1] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B1_count[idx1]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B1_count);
	timer_1.stop();
	taco::util::TimeResults res_1 = timer_1.getResult();
	cout << " , (1, []) ";
	cout << " , "<< res_1 ;
	taco::util::Timer timer_2;
	timer_2.start();

	// Histogram sort on mode 2
	int B2_size = dimensions[2];
	int32_t *B2_count = (int32_t *)calloc(B2_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx2 = C_coords[i].idx2;
		B2_count[idx2]++;
	}

	// Prefix sum over B2_count
	for(int idx2 = 1; idx2 < B2_size; idx2 ++)
	{
		B2_count[idx2] += B2_count[idx2 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx2 = C_coords[i].idx2;
		int idx = B2_count[idx2] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B2_count[idx2]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B2_count);
	timer_2.stop();
	taco::util::TimeResults res_2 = timer_2.getResult();
	cout << " , (2, []) ";
	cout << " , "<< res_2 ;
	taco::util::Timer timer_3;
	timer_3.start();

	// Histogram sort on mode 3
	int B3_size = dimensions[3];
	int32_t *B3_count = (int32_t *)calloc(B3_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx3 = C_coords[i].idx3;
		B3_count[idx3]++;
	}

	// Prefix sum over B3_count
	for(int idx3 = 1; idx3 < B3_size; idx3 ++)
	{
		B3_count[idx3] += B3_count[idx3 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx3 = C_coords[i].idx3;
		int idx = B3_count[idx3] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B3_count[idx3]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B3_count);
	timer_3.stop();
	taco::util::TimeResults res_3 = timer_3.getResult();
	cout << " , (3, []) ";
	cout << " , "<< res_3 ;
	taco::util::Timer timer_4;
	timer_4.start();

	// Histogram sort on mode 4
	int B4_size = dimensions[4];
	int32_t *B4_count = (int32_t *)calloc(B4_size, sizeof(int32_t));
	for( int i = 0; i < c_size; i++)
	{
		int32_t idx4 = C_coords[i].idx4;
		B4_count[idx4]++;
	}

	// Prefix sum over B4_count
	for(int idx4 = 1; idx4 < B4_size; idx4 ++)
	{
		B4_count[idx4] += B4_count[idx4 - 1];
	}
	for( int i = c_size - 1; i >= 0; i--)
	{
		int32_t idx4 = C_coords[i].idx4;
		int idx = B4_count[idx4] - 1;
		C_coords_scratch[idx] = C_coords[i];
		B4_count[idx4]--;
	}

	memcpy(C_coords, C_coords_scratch, c_size*sizeof(struct coo_t));


	free(B4_count);
	timer_4.stop();
	taco::util::TimeResults res_4 = timer_4.getResult();
	cout << " , (4, []) ";
	cout << " , "<< res_4 ;
	// Free the scratch space.
	free(C_coords_scratch);
	free(perm);
	return 0;
}

int main(int argc, char* argv[]) {
  char *p;
  int SPLIT;
   std::string filename = argv[1];

  long conv = strtol(argv[2], &p, 10);
  SPLIT = conv;

  // Read tensor data  
  int order = 5;
  int * dimensions = (int*)malloc(sizeof(int)*order);
  memset(dimensions, 0, sizeof(int)*order);
  
  int32_t init_alloc_size = 1048576;
  int32_t A_capacity = init_alloc_size;
  struct coo_t *A = (struct coo_t *)malloc(sizeof(struct coo_t)* A_capacity);

  std::fstream stream;
  util::openStream(stream, filename, fstream::in);

  std::string line;
  if (!std::getline(stream, line)) {
    return -1;
  }


  int size = 0;

  do {
      if(size >= A_capacity){
          int32_t A_capacity_new = 2 * (A_capacity);
          A = (struct coo_t*)realloc(A, sizeof(struct coo_t) * A_capacity_new);
          A_capacity = A_capacity_new;
        }

    char* linePtr = (char*)line.data();

    // Generated by coo/gen_taco_to_list.py

	long idx0 = strtol(linePtr, &linePtr, 10);
	A[size].idx0 = (int32_t)idx0 - 1;
	dimensions[0] = std::max(dimensions[0], (int)idx0);
	long idx1 = strtol(linePtr, &linePtr, 10);
	A[size].idx1 = (int32_t)idx1 - 1;
	dimensions[1] = std::max(dimensions[1], (int)idx1);
	long idx2 = strtol(linePtr, &linePtr, 10);
	A[size].idx2 = (int32_t)idx2 - 1;
	dimensions[2] = std::max(dimensions[2], (int)idx2);
	long idx3 = strtol(linePtr, &linePtr, 10);
	A[size].idx3 = (int32_t)idx3 - 1;
	dimensions[3] = std::max(dimensions[3], (int)idx3);
	long idx4 = strtol(linePtr, &linePtr, 10);
	A[size].idx4 = (int32_t)idx4 - 1;
	dimensions[4] = std::max(dimensions[4], (int)idx4);

    double val = strtod(linePtr, &linePtr);
    A[size].val = val;
    size ++;

  } while (std::getline(stream, line));

  stream.close();

  // Copy the tensor to test correctness.
  struct coo_t *A_copy = (coo_t*)malloc(sizeof(struct coo_t)*size);
  memcpy(A_copy, A, sizeof(struct coo_t)*size);


		if(0 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01234);
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(1 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01234);
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(2 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01234);
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(3 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01234);
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 3 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(4 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01234);
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 4 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(5 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01234);
		// (0, 1, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01234 | 5 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01234_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(6 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01243);
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(7 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01243);
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(8 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01243);
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(9 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01243);
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 3 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(10 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01243);
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(11 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01243);
		// (0, 1, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01243 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01243_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 2, 4, 3): [(4, [0, 1, 2])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(12 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01324);
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(13 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01324);
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(14 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01324);
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(15 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01324);
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(16 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01324);
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(17 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01324);
		// (0, 1, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01324 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01324_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 2, 4): [(3, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(18 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01342);
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(19 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01342);
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(20 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01342);
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(21 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01342);
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 4, 2): [(3, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(22 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01342);
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(23 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01342);
		// (0, 1, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01342 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01342_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 3, 4, 2): [(4, [0, 1]), (3, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(24 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01423);
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(25 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01423);
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(26 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01423);
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(27 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01423);
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(28 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01423);
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(29 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01423);
		// (0, 1, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01423 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01423_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 2, 3): [(4, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(30 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01432);
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(31 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01432);
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(32 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01432);
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 2 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(33 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01432);
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 3, 2): [(4, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(34 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01432);
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(35 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_01432);
		// (0, 1, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 01432 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_01432_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 1, 4, 3, 2): [(3, [0, 1]), (4, [0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(36 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02134);
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(37 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02134);
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(38 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02134);
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(39 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02134);
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(40 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02134);
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(41 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02134);
		// (0, 2, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02134 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02134_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 3, 4): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(42 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02143);
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(43 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02143);
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(44 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02143);
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(45 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02143);
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 4, 3): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(46 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02143);
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(47 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02143);
		// (0, 2, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02143 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02143_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 1, 4, 3): [(2, [0]), (4, [0, 2, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(48 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02314);
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(49 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02314);
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(50 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02314);
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 1, 4): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(51 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02314);
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(52 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02314);
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(53 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02314);
		// (0, 2, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02314 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02314_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 1, 4): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(54 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02341);
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(55 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02341);
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(56 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02341);
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 4, 1): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(57 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02341);
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 4, 1): [(3, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(58 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02341);
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(59 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02341);
		// (0, 2, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02341 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02341_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 3, 4, 1): [(4, [0]), (3, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(60 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02413);
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(61 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02413);
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(62 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02413);
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 1, 3): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(63 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02413);
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(64 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02413);
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(65 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02413);
		// (0, 2, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02413 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02413_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 1, 3): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(66 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02431);
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(67 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02431);
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(68 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02431);
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 3, 1): [(2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(69 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02431);
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 3, 1): [(4, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(70 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02431);
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(71 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_02431);
		// (0, 2, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 02431 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_02431_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 2, 4, 3, 1): [(3, [0]), (4, [0]), (2, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(72 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03124);
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(73 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03124);
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(74 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03124);
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(75 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03124);
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(76 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03124);
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(77 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03124);
		// (0, 3, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03124 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03124_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 2, 4): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(78 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03142);
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(79 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03142);
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(80 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03142);
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(81 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03142);
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 4, 2): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(82 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03142);
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(83 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03142);
		// (0, 3, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03142 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03142_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 1, 4, 2): [(3, [0]), (4, [0, 3, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(84 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03214);
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(85 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03214);
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(86 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03214);
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 1, 4): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(87 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03214);
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(88 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03214);
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(89 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03214);
		// (0, 3, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03214 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03214_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 1, 4): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(90 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03241);
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(91 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03241);
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(92 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03241);
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 4, 1): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(93 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03241);
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 4, 1): [(2, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(94 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03241);
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(95 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03241);
		// (0, 3, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03241 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03241_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 2, 4, 1): [(4, [0]), (2, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(96 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03412);
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(97 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03412);
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(98 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03412);
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 1, 2): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(99 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03412);
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(100 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03412);
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(101 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03412);
		// (0, 3, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03412 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03412_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 1, 2): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(102 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03421);
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(103 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03421);
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(104 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03421);
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 2, 1): [(3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(105 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03421);
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 2, 1): [(4, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(106 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03421);
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(107 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_03421);
		// (0, 3, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 03421 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_03421_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 3, 4, 2, 1): [(2, [0]), (4, [0]), (3, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(108 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04123);
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(109 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04123);
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(110 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04123);
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(111 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04123);
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(112 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04123);
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(113 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04123);
		// (0, 4, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04123 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04123_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 2, 3): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(114 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04132);
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(115 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04132);
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(116 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04132);
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(117 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04132);
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 3, 2): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(118 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04132);
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(119 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04132);
		// (0, 4, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04132 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04132_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 1, 3, 2): [(4, [0]), (3, [0, 4, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(120 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04213);
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(121 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04213);
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(122 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04213);
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 1, 3): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(123 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04213);
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(124 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04213);
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(125 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04213);
		// (0, 4, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04213 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04213_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 1, 3): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(126 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04231);
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(127 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04231);
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(128 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04231);
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 3, 1): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(129 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04231);
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 3, 1): [(2, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(130 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04231);
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(131 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04231);
		// (0, 4, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04231 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04231_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 2, 3, 1): [(3, [0]), (2, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(132 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04312);
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(133 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04312);
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(134 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04312);
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 1, 2): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(135 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04312);
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(136 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04312);
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(137 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04312);
		// (0, 4, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04312 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04312_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 1, 2): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(138 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04321);
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(139 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04321);
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 1 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(140 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04321);
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 2, 1): [(4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(141 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04321);
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 2, 1): [(3, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(142 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04321);
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(143 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_04321);
		// (0, 4, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 04321 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_04321_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (0, 4, 3, 2, 1): [(2, [0]), (3, [0]), (4, [0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(144 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10234);
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(145 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10234);
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(146 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10234);
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(147 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10234);
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(148 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10234);
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(149 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10234);
		// (1, 0, 2, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10234 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10234_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(150 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10243);
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(151 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10243);
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(152 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10243);
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(153 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10243);
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(154 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10243);
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(155 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10243);
		// (1, 0, 2, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10243 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10243_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 2, 4, 3): [(1, []), (4, [1, 0, 2])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(156 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10324);
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(157 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10324);
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(158 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10324);
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(159 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10324);
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(160 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10324);
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(161 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10324);
		// (1, 0, 3, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10324 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10324_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 2, 4): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(162 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10342);
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(163 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10342);
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(164 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10342);
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(165 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10342);
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 4, 2): [(1, []), (3, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(166 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10342);
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(167 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10342);
		// (1, 0, 3, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10342 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10342_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 3, 4, 2): [(1, []), (4, [1, 0]), (3, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(168 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10423);
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(169 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10423);
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(170 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10423);
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(171 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10423);
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(172 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10423);
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(173 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10423);
		// (1, 0, 4, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10423 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10423_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 2, 3): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(174 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10432);
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(175 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10432);
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(176 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10432);
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(177 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10432);
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 3, 2): [(1, []), (4, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(178 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10432);
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(179 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_10432);
		// (1, 0, 4, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 10432 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_10432_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 0, 4, 3, 2): [(1, []), (3, [1, 0]), (4, [1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(180 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12034);
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(181 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12034);
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 3, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(182 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12034);
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(183 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12034);
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(184 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12034);
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(185 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12034);
		// (1, 2, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12034 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12034_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 3, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(186 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12043);
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(187 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12043);
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 4, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(188 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12043);
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(189 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12043);
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 4, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(190 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12043);
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(191 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12043);
		// (1, 2, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12043 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12043_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 0, 4, 3): [(2, []), (1, []), (4, [1, 2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(192 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12304);
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 0, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(193 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12304);
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(194 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12304);
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 0, 4): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(195 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12304);
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(196 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12304);
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(197 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12304);
		// (1, 2, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12304 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12304_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 0, 4): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(198 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12340);
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 4, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(199 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12340);
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(200 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12340);
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 4, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(201 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12340);
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 4, 0): [(3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(202 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12340);
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(203 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12340);
		// (1, 2, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12340 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12340_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 3, 4, 0): [(4, []), (3, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(204 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12403);
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 0, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(205 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12403);
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(206 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12403);
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 0, 3): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(207 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12403);
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(208 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12403);
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(209 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12403);
		// (1, 2, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12403 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12403_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 0, 3): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(210 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12430);
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 3, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(211 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12430);
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(212 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12430);
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 3, 0): [(2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(213 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12430);
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 3, 0): [(4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(214 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12430);
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(215 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_12430);
		// (1, 2, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 12430 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_12430_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 2, 4, 3, 0): [(3, []), (4, []), (2, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(216 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13024);
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(217 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13024);
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 2, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(218 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13024);
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(219 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13024);
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(220 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13024);
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(221 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13024);
		// (1, 3, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13024 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13024_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 2, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(222 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13042);
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(223 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13042);
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 4, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(224 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13042);
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(225 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13042);
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 4, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(226 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13042);
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(227 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13042);
		// (1, 3, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13042 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13042_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 0, 4, 2): [(3, []), (1, []), (4, [1, 3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(228 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13204);
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 0, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(229 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13204);
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 0, 4): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(230 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13204);
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 0, 4): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(231 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13204);
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(232 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13204);
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(233 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13204);
		// (1, 3, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13204 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13204_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 0, 4): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(234 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13240);
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 4, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(235 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13240);
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 4, 0): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(236 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13240);
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 4, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(237 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13240);
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 4, 0): [(2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(238 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13240);
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(239 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13240);
		// (1, 3, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13240 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13240_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 2, 4, 0): [(4, []), (2, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(240 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13402);
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 0, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(241 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13402);
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(242 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13402);
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 0, 2): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(243 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13402);
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(244 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13402);
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(245 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13402);
		// (1, 3, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13402 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13402_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 0, 2): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(246 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13420);
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 2, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(247 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13420);
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(248 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13420);
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 2, 0): [(3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(249 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13420);
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 2, 0): [(4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(250 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13420);
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(251 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_13420);
		// (1, 3, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 13420 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_13420_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 3, 4, 2, 0): [(2, []), (4, []), (3, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(252 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14023);
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(253 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14023);
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 2, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(254 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14023);
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(255 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14023);
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(256 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14023);
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(257 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14023);
		// (1, 4, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14023 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14023_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 2, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(258 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14032);
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(259 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14032);
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 3, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(260 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14032);
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(261 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14032);
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 3, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(262 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14032);
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(263 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14032);
		// (1, 4, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14032 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14032_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 0, 3, 2): [(4, []), (1, []), (3, [1, 4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(264 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14203);
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 0, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(265 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14203);
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 0, 3): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(266 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14203);
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 0, 3): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(267 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14203);
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(268 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14203);
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(269 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14203);
		// (1, 4, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14203 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14203_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 0, 3): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(270 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14230);
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 3, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(271 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14230);
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 3, 0): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(272 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14230);
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 3, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(273 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14230);
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 3, 0): [(2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(274 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14230);
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(275 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14230);
		// (1, 4, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14230 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14230_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 2, 3, 0): [(3, []), (2, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(276 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14302);
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 0, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(277 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14302);
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 0, 2): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(278 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14302);
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 0, 2): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(279 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14302);
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(280 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14302);
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(281 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14302);
		// (1, 4, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14302 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14302_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 0, 2): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(282 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14320);
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 2, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(283 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14320);
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 2, 0): [(1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(284 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14320);
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 2, 0): [(4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(285 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14320);
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 2, 0): [(3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(286 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14320);
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(287 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_14320);
		// (1, 4, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 14320 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_14320_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (1, 4, 3, 2, 0): [(2, []), (3, []), (4, []), (1, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(288 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20134);
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(289 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20134);
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(290 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20134);
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(291 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20134);
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(292 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20134);
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(293 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20134);
		// (2, 0, 1, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20134 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20134_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(294 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20143);
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(295 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20143);
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(296 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20143);
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(297 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20143);
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(298 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20143);
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(299 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20143);
		// (2, 0, 1, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20143 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20143_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 1, 4, 3): [(2, []), (4, [2, 0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(300 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20314);
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(301 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20314);
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(302 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20314);
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(303 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20314);
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(304 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20314);
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(305 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20314);
		// (2, 0, 3, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20314 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20314_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 1, 4): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(306 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20341);
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(307 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20341);
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(308 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20341);
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(309 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20341);
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 4, 1): [(2, []), (3, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(310 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20341);
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(311 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20341);
		// (2, 0, 3, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20341 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20341_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 3, 4, 1): [(2, []), (4, [2, 0]), (3, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(312 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20413);
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(313 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20413);
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(314 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20413);
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(315 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20413);
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(316 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20413);
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(317 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20413);
		// (2, 0, 4, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20413 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20413_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 1, 3): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(318 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20431);
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(319 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20431);
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(320 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20431);
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(321 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20431);
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 3, 1): [(2, []), (4, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(322 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20431);
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(323 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_20431);
		// (2, 0, 4, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 20431 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_20431_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 0, 4, 3, 1): [(2, []), (3, [2, 0]), (4, [2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(324 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21034);
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 3, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(325 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21034);
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 3, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(326 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21034);
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(327 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21034);
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(328 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21034);
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(329 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21034);
		// (2, 1, 0, 3, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21034 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21034_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 3, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(330 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21043);
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 4, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(331 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21043);
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 4, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(332 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21043);
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(333 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21043);
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 4, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(334 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21043);
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(335 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21043);
		// (2, 1, 0, 4, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21043 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21043_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 0, 4, 3): [(1, []), (2, []), (4, [2, 1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(336 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21304);
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 0, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(337 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21304);
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(338 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21304);
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 0, 4): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(339 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21304);
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(340 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21304);
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(341 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21304);
		// (2, 1, 3, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21304 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21304_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 0, 4): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(342 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21340);
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 4, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(343 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21340);
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(344 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21340);
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 4, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(345 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21340);
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 4, 0): [(3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(346 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21340);
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(347 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21340);
		// (2, 1, 3, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21340 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21340_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 3, 4, 0): [(4, []), (3, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(348 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21403);
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 0, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(349 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21403);
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(350 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21403);
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 0, 3): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(351 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21403);
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(352 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21403);
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(353 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21403);
		// (2, 1, 4, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21403 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21403_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 0, 3): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(354 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21430);
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 3, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(355 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21430);
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(356 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21430);
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 3, 0): [(1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(357 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21430);
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 3, 0): [(4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(358 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21430);
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(359 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_21430);
		// (2, 1, 4, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 21430 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_21430_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 1, 4, 3, 0): [(3, []), (4, []), (1, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(360 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23014);
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(361 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23014);
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 1, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(362 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23014);
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(363 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23014);
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(364 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23014);
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(365 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23014);
		// (2, 3, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23014 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23014_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 1, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(366 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23041);
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(367 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23041);
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 4, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(368 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23041);
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(369 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23041);
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 4, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(370 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23041);
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(371 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23041);
		// (2, 3, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23041 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23041_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 0, 4, 1): [(3, []), (2, []), (4, [2, 3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(372 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23104);
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 0, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(373 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23104);
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 0, 4): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(374 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23104);
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 0, 4): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(375 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23104);
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(376 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23104);
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(377 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23104);
		// (2, 3, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23104 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23104_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 0, 4): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(378 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23140);
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 4, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(379 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23140);
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 4, 0): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(380 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23140);
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 4, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(381 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23140);
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 4, 0): [(1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(382 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23140);
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(383 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23140);
		// (2, 3, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23140 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23140_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 1, 4, 0): [(4, []), (1, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(384 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23401);
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 0, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(385 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23401);
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(386 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23401);
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 0, 1): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(387 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23401);
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(388 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23401);
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(389 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23401);
		// (2, 3, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23401 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23401_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 0, 1): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(390 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23410);
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 1, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(391 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23410);
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(392 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23410);
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 1, 0): [(3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(393 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23410);
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 1, 0): [(4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(394 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23410);
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(395 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_23410);
		// (2, 3, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 23410 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_23410_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 3, 4, 1, 0): [(1, []), (4, []), (3, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(396 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24013);
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(397 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24013);
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 1, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(398 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24013);
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(399 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24013);
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(400 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24013);
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(401 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24013);
		// (2, 4, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24013 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24013_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 1, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(402 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24031);
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(403 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24031);
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 3, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(404 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24031);
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(405 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24031);
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 3, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(406 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24031);
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(407 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24031);
		// (2, 4, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24031 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24031_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 0, 3, 1): [(4, []), (2, []), (3, [2, 4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(408 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24103);
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 0, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(409 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24103);
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 0, 3): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(410 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24103);
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 0, 3): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(411 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24103);
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(412 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24103);
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(413 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24103);
		// (2, 4, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24103 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24103_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 0, 3): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(414 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24130);
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 3, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(415 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24130);
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 3, 0): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(416 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24130);
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 3, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(417 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24130);
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 3, 0): [(1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(418 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24130);
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(419 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24130);
		// (2, 4, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24130 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24130_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 1, 3, 0): [(3, []), (1, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(420 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24301);
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 0, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(421 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24301);
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 0, 1): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(422 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24301);
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 0, 1): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(423 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24301);
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(424 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24301);
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(425 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24301);
		// (2, 4, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24301 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24301_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 0, 1): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(426 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24310);
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 1, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(427 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24310);
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 1, 0): [(2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(428 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24310);
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 1, 0): [(4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(429 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24310);
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 1, 0): [(3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(430 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24310);
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(431 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_24310);
		// (2, 4, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 24310 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_24310_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (2, 4, 3, 1, 0): [(1, []), (3, []), (4, []), (2, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(432 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30124);
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(433 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30124);
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(434 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30124);
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(435 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30124);
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(436 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30124);
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(437 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30124);
		// (3, 0, 1, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30124 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30124_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(438 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30142);
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(439 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30142);
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(440 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30142);
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(441 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30142);
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(442 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30142);
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(443 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30142);
		// (3, 0, 1, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30142 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30142_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 1, 4, 2): [(3, []), (4, [3, 0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(444 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30214);
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(445 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30214);
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(446 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30214);
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(447 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30214);
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(448 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30214);
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(449 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30214);
		// (3, 0, 2, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30214 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30214_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 1, 4): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(450 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30241);
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(451 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30241);
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(452 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30241);
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(453 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30241);
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 4, 1): [(3, []), (2, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(454 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30241);
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(455 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30241);
		// (3, 0, 2, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30241 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30241_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 2, 4, 1): [(3, []), (4, [3, 0]), (2, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(456 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30412);
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(457 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30412);
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(458 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30412);
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(459 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30412);
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(460 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30412);
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(461 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30412);
		// (3, 0, 4, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30412 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30412_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 1, 2): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(462 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30421);
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(463 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30421);
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(464 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30421);
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(465 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30421);
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 2, 1): [(3, []), (4, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(466 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30421);
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(467 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_30421);
		// (3, 0, 4, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 30421 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_30421_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 0, 4, 2, 1): [(3, []), (2, [3, 0]), (4, [3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(468 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31024);
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 2, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(469 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31024);
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 2, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(470 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31024);
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(471 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31024);
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(472 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31024);
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(473 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31024);
		// (3, 1, 0, 2, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31024 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31024_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 2, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(474 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31042);
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 4, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(475 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31042);
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 4, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(476 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31042);
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(477 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31042);
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 4, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(478 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31042);
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(479 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31042);
		// (3, 1, 0, 4, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31042 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31042_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 0, 4, 2): [(1, []), (3, []), (4, [3, 1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(480 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31204);
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 0, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(481 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31204);
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(482 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31204);
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 0, 4): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(483 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31204);
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(484 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31204);
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(485 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31204);
		// (3, 1, 2, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31204 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31204_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 0, 4): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(486 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31240);
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 4, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(487 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31240);
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(488 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31240);
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 4, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(489 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31240);
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 4, 0): [(2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(490 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31240);
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(491 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31240);
		// (3, 1, 2, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31240 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31240_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 2, 4, 0): [(4, []), (2, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(492 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31402);
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 0, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(493 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31402);
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(494 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31402);
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 0, 2): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(495 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31402);
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(496 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31402);
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(497 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31402);
		// (3, 1, 4, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31402 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31402_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 0, 2): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(498 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31420);
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 2, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(499 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31420);
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(500 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31420);
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 2, 0): [(1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(501 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31420);
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 2, 0): [(4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(502 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31420);
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(503 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_31420);
		// (3, 1, 4, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 31420 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_31420_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 1, 4, 2, 0): [(2, []), (4, []), (1, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(504 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32014);
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 1, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(505 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32014);
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 1, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(506 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32014);
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(507 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32014);
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(508 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32014);
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(509 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32014);
		// (3, 2, 0, 1, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32014 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32014_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 1, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(510 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32041);
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 4, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(511 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32041);
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 4, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(512 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32041);
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(513 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32041);
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 4, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(514 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32041);
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(515 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32041);
		// (3, 2, 0, 4, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32041 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32041_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 0, 4, 1): [(2, []), (3, []), (4, [3, 2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(516 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32104);
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 0, 4): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(517 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32104);
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 0, 4): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(518 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32104);
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 0, 4): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(519 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32104);
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(520 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32104);
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(521 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32104);
		// (3, 2, 1, 0, 4)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32104 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32104_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 0, 4): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(522 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32140);
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 4, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(523 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32140);
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 4, 0): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(524 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32140);
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 4, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(525 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32140);
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 4, 0): [(1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(526 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32140);
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(527 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32140);
		// (3, 2, 1, 4, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32140 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32140_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 1, 4, 0): [(4, []), (1, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(528 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32401);
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 0, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(529 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32401);
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(530 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32401);
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 0, 1): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(531 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32401);
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(532 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32401);
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(533 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32401);
		// (3, 2, 4, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32401 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32401_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 0, 1): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(534 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32410);
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 1, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(535 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32410);
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(536 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32410);
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 1, 0): [(2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(537 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32410);
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 1, 0): [(4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(538 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32410);
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(539 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_32410);
		// (3, 2, 4, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 32410 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_32410_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 2, 4, 1, 0): [(1, []), (4, []), (2, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(540 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34012);
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(541 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34012);
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 1, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(542 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34012);
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(543 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34012);
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(544 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34012);
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(545 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34012);
		// (3, 4, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34012 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34012_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 1, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(546 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34021);
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(547 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34021);
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 2, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(548 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34021);
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(549 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34021);
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 2, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(550 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34021);
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(551 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34021);
		// (3, 4, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34021 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34021_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 0, 2, 1): [(4, []), (3, []), (2, [3, 4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(552 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34102);
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 0, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(553 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34102);
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 0, 2): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(554 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34102);
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 0, 2): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(555 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34102);
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(556 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34102);
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(557 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34102);
		// (3, 4, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34102 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34102_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 0, 2): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(558 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34120);
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 2, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(559 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34120);
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 2, 0): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(560 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34120);
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 2, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(561 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34120);
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 2, 0): [(1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(562 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34120);
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(563 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34120);
		// (3, 4, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34120 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34120_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 1, 2, 0): [(2, []), (1, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(564 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34201);
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 0, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(565 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34201);
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 0, 1): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(566 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34201);
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 0, 1): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(567 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34201);
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(568 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34201);
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(569 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34201);
		// (3, 4, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34201 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34201_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 0, 1): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(570 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34210);
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 1, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(571 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34210);
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 1, 0): [(3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(572 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34210);
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 1, 0): [(4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(573 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34210);
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 1, 0): [(2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(574 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34210);
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(575 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_34210);
		// (3, 4, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 34210 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_34210_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (3, 4, 2, 1, 0): [(1, []), (2, []), (4, []), (3, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(576 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40123);
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(577 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40123);
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(578 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40123);
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(579 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40123);
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(580 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40123);
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 4 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(581 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40123);
		// (4, 0, 1, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40123 | 5 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40123_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(582 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40132);
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(583 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40132);
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(584 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40132);
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(585 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40132);
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 3 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(586 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40132);
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(587 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40132);
		// (4, 0, 1, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40132 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40132_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 1, 3, 2): [(4, []), (3, [4, 0, 1])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(588 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40213);
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(589 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40213);
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(590 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40213);
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(591 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40213);
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(592 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40213);
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(593 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40213);
		// (4, 0, 2, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40213 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40213_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 1, 3): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(594 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40231);
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(595 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40231);
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(596 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40231);
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(597 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40231);
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 3, 1): [(4, []), (2, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(598 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40231);
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(599 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40231);
		// (4, 0, 2, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40231 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40231_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 2, 3, 1): [(4, []), (3, [4, 0]), (2, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(600 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40312);
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(601 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40312);
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(602 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40312);
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(603 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40312);
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(604 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40312);
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(605 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40312);
		// (4, 0, 3, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40312 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40312_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 1, 2): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(606 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40321);
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(607 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40321);
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(608 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40321);
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 2 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(609 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40321);
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 2, 1): [(4, []), (3, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(610 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40321);
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(611 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_40321);
		// (4, 0, 3, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 40321 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_40321_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 0, 3, 2, 1): [(4, []), (2, [4, 0]), (3, [4, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(612 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41023);
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 2, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(613 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41023);
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 2, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(614 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41023);
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(615 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41023);
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(616 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41023);
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(617 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41023);
		// (4, 1, 0, 2, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41023 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41023_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 2, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(618 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41032);
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 3, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(619 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41032);
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 3, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(620 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41032);
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(621 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41032);
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 3, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(622 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41032);
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(623 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41032);
		// (4, 1, 0, 3, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41032 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41032_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 0, 3, 2): [(1, []), (4, []), (3, [4, 1, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(624 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41203);
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 0, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(625 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41203);
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(626 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41203);
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 0, 3): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(627 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41203);
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(628 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41203);
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(629 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41203);
		// (4, 1, 2, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41203 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41203_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 0, 3): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(630 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41230);
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 3, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(631 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41230);
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(632 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41230);
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 3, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(633 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41230);
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 3, 0): [(2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(634 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41230);
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(635 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41230);
		// (4, 1, 2, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41230 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41230_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 2, 3, 0): [(3, []), (2, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(636 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41302);
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 0, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(637 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41302);
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(638 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41302);
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 0, 2): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(639 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41302);
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(640 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41302);
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(641 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41302);
		// (4, 1, 3, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41302 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41302_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 0, 2): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(642 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41320);
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 2, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(643 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41320);
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(644 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41320);
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 2, 0): [(1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(645 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41320);
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 2, 0): [(3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(646 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41320);
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(647 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_41320);
		// (4, 1, 3, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 41320 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_41320_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 1, 3, 2, 0): [(2, []), (3, []), (1, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(648 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42013);
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 1, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(649 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42013);
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 1, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(650 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42013);
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(651 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42013);
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(652 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42013);
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(653 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42013);
		// (4, 2, 0, 1, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42013 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42013_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 1, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(654 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42031);
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 3, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(655 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42031);
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 3, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(656 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42031);
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(657 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42031);
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 3, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(658 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42031);
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(659 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42031);
		// (4, 2, 0, 3, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42031 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42031_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 0, 3, 1): [(2, []), (4, []), (3, [4, 2, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(660 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42103);
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 0, 3): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(661 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42103);
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 0, 3): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(662 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42103);
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 0, 3): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(663 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42103);
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(664 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42103);
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(665 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42103);
		// (4, 2, 1, 0, 3)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42103 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42103_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 0, 3): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(666 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42130);
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 3, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(667 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42130);
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 3, 0): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(668 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42130);
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 3, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(669 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42130);
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 3, 0): [(1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(670 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42130);
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(671 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42130);
		// (4, 2, 1, 3, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42130 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42130_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 1, 3, 0): [(3, []), (1, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(672 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42301);
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 0, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(673 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42301);
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(674 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42301);
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 0, 1): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(675 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42301);
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(676 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42301);
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(677 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42301);
		// (4, 2, 3, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42301 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42301_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 0, 1): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(678 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42310);
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 1, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(679 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42310);
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(680 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42310);
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 1, 0): [(2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(681 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42310);
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 1, 0): [(3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(682 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42310);
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(683 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_42310);
		// (4, 2, 3, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 42310 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_42310_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 2, 3, 1, 0): [(1, []), (3, []), (2, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(684 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43012);
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 1, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(685 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43012);
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 1, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(686 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43012);
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(687 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43012);
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(688 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43012);
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 4 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(689 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43012);
		// (4, 3, 0, 1, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43012 | 5 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43012_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 1, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(690 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43021);
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 2, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(691 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43021);
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 2, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(692 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43021);
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(693 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43021);
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 3 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 2, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(694 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43021);
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(695 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43021);
		// (4, 3, 0, 2, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43021 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43021_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 0, 2, 1): [(3, []), (4, []), (2, [4, 3, 0])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(696 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43102);
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 0, 2): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(697 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43102);
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 0, 2): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(698 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43102);
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 0, 2): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(699 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43102);
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(700 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43102);
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(701 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43102);
		// (4, 3, 1, 0, 2)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43102 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43102_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 0, 2): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(702 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43120);
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 2, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(703 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43120);
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 2, 0): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(704 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43120);
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 2, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(705 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43120);
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 2, 0): [(1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(706 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43120);
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(707 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43120);
		// (4, 3, 1, 2, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43120 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43120_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 1, 2, 0): [(2, []), (1, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(708 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43201);
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 0, 1): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(709 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43201);
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 0, 1): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(710 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43201);
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 0, 1): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(711 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43201);
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(712 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43201);
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 4 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(713 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43201);
		// (4, 3, 2, 0, 1)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43201 | 5 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43201_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 0, 1): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(714 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43210);
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 0 | 0" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k0(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): []" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 1, 0): []" << endl;
					exit(3);
				}
			}
		}

		}
		if(715 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43210);
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 1 | 1" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k1(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 1, 0): [(4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(716 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43210);
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 2 | 2" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k2(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 1, 0): [(3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(717 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43210);
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 3 | 3" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k3(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 1, 0): [(2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(718 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43210);
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 4 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k4(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
		if(719 == SPLIT){
		// Sort the copy to the desired permutation.
			qsort(A_copy, size, sizeof(struct coo_t), cmp_43210);
		// (4, 3, 2, 1, 0)
		for(int i = 0; i < 100; i ++){
			cout << filename << " | 43210 | 5 | 4" ;
			qsort(A, size, sizeof(struct coo_t), cmp_01234);
			transpose_coo_43210_k5(A, size, order, dimensions);
			cout << endl;
			// Check that it was permuted correctly.
			for(int i = 0; i < size; i ++) {
				if(A[i].idx0 != A_copy[i].idx0){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx1 != A_copy[i].idx1){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx2 != A_copy[i].idx2){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx3 != A_copy[i].idx3){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].idx4 != A_copy[i].idx4){
					cout << "Error permuting array: index incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
				if(A[i].val != A_copy[i].val){
					cout << "Error permuting array: value incorrect: (4, 3, 2, 1, 0): [(1, []), (2, []), (3, []), (4, [])]" << endl;
					exit(3);
				}
			}
		}

		}
	free(A);
	free(dimensions);
}
